---
title: "Data programming"
subtitle: "Data Analysis in R"
title-slide-attributes:
  data-background-image: img/data-science-2.jpeg
  data-background-size: cover
  data-background-opacity: "0.2"
author: "Master in Computational Social Sciences ‚Ä¢ 2023-2024"
affiliation: UC3M
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    chalkboard: true
    multiplex: true
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier √Ålvarez Li√©bana</strong>](...) ‚Ä¢ Master in Computational Social Sciences ‚Ä¢ 2023-2024"
    slide-number: c/t
execute:
  echo: true
---

# Welcome to R!

[**Put your spreadsheets aside**]{style="color:#444442;"}

---

## Hi!

[**Mail**]{.hl-green}: **<javiealv@pa.uc3m.es**> and **<javalv09@ucm.es>**. 

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
- [**Javier √Ålvarez Li√©bana**]{.hl-yellow} from Carabanchel (Madrid).

- Degree in Mathematics (UCM). [**PhD in Statistics**]{.hl-yellow} (UGR).

- In charge of  [**data visualization and analysis for the Principality of Asturias (2021-2022)**]{.hl-yellow} during the COVID pandemic.

- Member of the [**Spanish Society of Statistics and OR**]{.hl-yellow} and the [**Spanish Royal Mathematical Society**]{.hl-yellow}.

:::
:::
:::


. . .

Currently, [**researcher and lecturer at the Faculty of Statistics of the UCM**]{.hl-yellow}. Disseminating via [**Twitter**](https://twitter.com/dadosdelaplace) and [**Instagram**](https://instagram.com/javieralvarezliebana).

---

## Goals

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental

- Take away the [**fear of programming errors**]{.hl-yellow} ‚Üí learn to program by programming

- Understanding [**basic R concepts**]{.hl-yellow} from scratch ‚Üí learning to abstract ideas and algorithms

- Utility of programming ‚Üí [**reproducible**, **transparent**]{.hl-yellow} and maintainable workflows.

- Introduction to [**analysis and preprocessing**]{.hl-yellow} of data ‚Üí `{tidyverse}`.

- Handling [**advanced data types**]{.hl-yellow} ‚Üí `{forcats}`, `{lubridate}` and `{purrr}` packages

:::
:::
:::

---

## Evaluation

- [**Attendance and individual participation**]{.hl-yellow} in the class (10%)

. . .

- [**Individual work done during the course**]{.hl-yellow} (60%). Throughout the course there are [**3 individual task submissions**]{.hl-purple}.

. . .


- [**Group work**]{.hl-yellow} done at the end of the course (30%) (between 2 and 4 people), in which the analysis of a real case must be presented.


---

## Plannning

::: column-screen-inset-right
::: {style="font-size:20px"}
|  LESSON | WEEK | DATE | TOPIC | SCRIPTS | EJ. | CASO PR√ÅCTICO | ENTREGA | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
|     [1](#clase-1-primeros-pasos)      | S1     | 14 sep |                 R base programming                   | [üìù](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [üíª](#tu-turno)  [üíª](#tu-turno-1) [üíª](#tu-turno-2) |       [üê£](#caso-pr√°ctico-1)                  |         | 
|     [2](#clase-2)      | S2     | ¬ø? |                 First databases and   control flow estructures       | [üìù](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [üíª](#tu-turno-3)    |  [üê£](#caso-pr√°ctico-2)  |         |     
|     [3](#clase-3)      | S3    | ¬ø? |        Tidy data    | [üìù](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [üíª](#tu-turno-4)      |  [üê£](#caso-pr√°ctico-3)  |         |     

:::
:::

---

## Materials

* [**Slides**]{.hl-yellow}: the slides that we will use in the classroom throughout the course, structured by classes, will be available and updated at **<https://javieralvarezliebana.es/mucss-data-programming/slides>**. 

In the slide menu (bottom left) you have an [**option to download them in pdf**]{.hl-yellow} under `Tools` (tip: do not do this until the end of the course as they will be modified).

  
&nbsp;

* [**Package summaries**]{.hl-yellow}: [**package cheatsheets**](https://github.com/dadosdelaplace/mucss-data-programming/tree/main/cheatsheets) in .pdf format


# Lesson 1: R base programming {#clase-1-primeros-pasos}

[**Introduction to R and RStudio ecosystems. Working with projects. First uses of functions and packages. Basic data types.**]{style="color:#444442;"}


---

## Requirements

For the course the only requirements will be:

1. [**Internet connection**]{.hl-yellow} (for downloading some data and packages).

2. [**Installing R**]{.hl-yellow}[: it will be our language. The download will be done (free of charge) from <https://cran.r-project.org/>]{.fragment .fade-in}


::: {.fragment .fade-in}
3.  [**Installing RStudio**]{.hl-yellow} from <https://posit.co/download/rstudio-desktop/>
:::

::: columns
::: {.column width="50%"}
![](img/cranR.jpg){width="420"}
:::

::: {.column width="50%"}
![](img/rstudio.jpg){width="420"}
:::
:::

---

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="400"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="470"}
:::
:::

::: {.fragment .fade-in-then-out}
We will program as we write (English, for example) ‚Üí `R` is the [**language**]{.hl-yellow}
:::

::: {.fragment .fade-up}
- We will need a [**grammar**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}
- And an environment, for example a [**Word**]{.hl-yellow} (`RStudio`), to write it in.
:::
:::

---

## Installing R

The `R` language will be our [**grammar and spelling**]{.hl-yellow} (our rules).

::: incremental
- [**Step 1**]{.hl-yellow}: go to <https://cran.r-project.org/> and select your operating system.

- [**Step 2**]{.hl-yellow}: for Mac just click on the **.pkg file**, and open it once downloaded. For Windows systems, click on **install R for the first time** and then on **Download R for Windows**. Once downloaded, open it like any other installation file.

- [**Step 3**]{.hl-yellow}: open the installation executable.
:::

. . .

::: callout-warning
Whenever you download something from CRAN (either R itself or a package), [**make sure you have an internet connection**]{.hl-orange}.
:::

---

## First steps

::: columns
::: {.column width="65%"}
To check that it has been installed correctly, after opening `R`, you should see a **white screen** similar to this one.

That "white screen" is called [**console**]{.hl-yellow} and we can make a first use of it as a **calculator**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="200"}
:::
:::

. . .

[**Idea**]{.hl-yellow}: let us define a variable called `a`, and it will be assigned the value `1` (type the code below in the console and hit "enter").

```{r}
#| code-line-numbers: "1"
a <- 1
```

---

## First steps

::: columns
::: {.column width="65%"}
To check that it has been installed correctly, after opening `R`, you should see a **white screen** similar to this one.

That "white screen" is called [**console**]{.hl-yellow} and we can make a first use of it as a **calculator**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Idea**]{.hl-yellow}: we will define another variable called `b` and assign it the value `2`.


```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

. . .

::: callout-note
## Note that...

In `R` we use `<-` as an arrow: the variable to the left of the arrow is assigned the value to the right (e.g. `a <- 1`).

:::

---

## First steps

::: columns
::: {.column width="65%"}
To check that it has been installed correctly, after opening `R`, you should see a **white screen** similar to this one.

That "white screen" is called [**console**]{.hl-yellow} and we can make a first use of it as a **calculator**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="270"}
:::
:::

[**Idea**]{.hl-yellow}: we will do the sum `a + b` and it will return its result.

```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```

---

## Installing R Studio

`RStudio` will be the [**Word**]{.hl-yellow} that we will use to write (what is known as an [**IDE: integrated development environment**]{.hl-yellow}).

::: incremental
- [**Step 1**]{.hl-yellow}: go to the [official RStudio website](https://posit.co/download/rstudio-desktop/) (now called Posit) and select the free download.

- [**Step 2**]{.hl-yellow}: select the executable that appears according to your operating system.

- [**Step 3**]{.hl-yellow}: after downloading the executable, open it like any other executable and let the installation finish.
:::

---

## Pane layout in RStudio

When you open `RStudio` you will probably have three windows:

- [**Console**]{.hl-yellow}: this is the name to call the big window that takes up a good part of your screen. Try writing the same code as before (the sum of the variables) in it. The console will be where we will **execute commands and show results**.

![](img/consola_rstudio.jpg){width="420"}

---

## Pane layout in RStudio

When you open `RStudio` you will probably have three windows:

-   [**Environment**]{.hl-yellow}: the small screen (you can adjust the margins) located at the upper right part. It will show us the **variables we have defined**.

![](img/environment.jpg){width="420"}

---

## Pane layout in RStudio

When you open `RStudio` you will probably have three windows:

-   [**Multi-purpose panel**]{.hl-yellow}: the window at the bottom right will not only be used to search for **function help**, but also to **view graphics**.

![](img/multiusos.jpg){width="420"}

---

## Why R?

![](img/meme_barco.jpg)

---

## Why R?

`R` is the [**main statistical language**]{.hl-yellow}, created by and for statisticians, with 5 fundamental advantages [**over Excel**]{.hl-red}:

::: incremental

- [**Programming language**]{.hl-yellow}: obviousness ‚Üí [**replicable**]{.hl-purple} analysis.

- [**Free of charge**]{.hl-yellow}: the philosophy of the `R` community is code sharing under **copyleft** ‚Üí [**ethical use of public money**]{.hl-purple}

- [**Open source**]{.hl-yellow}: not only is it free but it allows free access to other people's code, even to **own source code** ‚Üí [**flexibility and transparency**]{.hl-purple}

- [**Modular language**]{.hl-yellow}: there are other people's code that we can reuse (almost 20 000 [**packages**]{.hl-yellow}) ‚Üí [**time-saving**]{.hl-purple}

- [**High-level language**]{.hl-yellow}

:::

---

## Why R?

![](img/incel_excel.png)

---

## Why programming?

- [**Automate**]{.hl-yellow} ‚Üí it will allow you to automate recurring tasks.

- [**Replicability**]{.hl-yellow} ‚Üí you will be able to replicate your analysis always in the same way.

- [**Flexibility**]{.hl-yellow} ‚Üí you will be able to adapt the software to your needs.

- [**Transparency**]{.hl-yellow} ‚Üí it could be audited by the community.

![](img/the_general_problem.png)

---

## Main idea: packages

One of the key ideas of `R` is the [**use of packages**]{.hl-yellow}: codes that other people have implemented to **solve a problem**.

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}
- [**Installing**]{.hl-yellow}: download the codes from the web (internet required) ‚Üí [**"buy a book"**]{.hl-purple}, only once (per computer)

```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}
- [**Loading**]{.hl-yellow}: after downloading the package, we indicate which packages we want to use each time we open `RStudio` ‚Üí [**bring the book off the shelf**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::
:::
:::

---

## Main idea: packages

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
Once installed, there are two ways to use a package (bring it off the shelf)

::: {.fragment fragment-index="1"}
-   [**The whole package**]{.hl-yellow}: with `library()`, using the package name without quotes, we load into our session the [**whole book**]{.hl-purple}.

```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}
- [**Some particular functions**]{.hl-yellow} using `package::function` we indicate that we only want a [**concrete page of that book**]{.hl-purple}.

```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## You will be wrong

During your learning process, it is going to be very common that things don't go right the first time ‚Üí [**you will make mistakes**]{.hl-yellow}. Not only will it be important to assume this, but it is [**important to read the error messages**]{.hl-yellow} to learn from them.

. . .

-   [**Error messages**]{.hl-red}: preceded by **"Error in... "** and will be those failures that [**prevent execution**]{.hl-red}.

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Warning messages**]{.hl-orange}: preceded by **"Warning in... "** are the most sensitive (possible) failures since they are inconsistencies that [**do not prevent execution**]{.hl-orange}.

```{r}
#| warning: true
# Code is ok but the result provided a NaN value, **Not A Number**, a value that is not a (real) number
sqrt(-1)
```

---

## Scripts (.R files)

::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}
A [**script**]{.hl-yellow} will be the document in which we program, our `.doc` file (here with `.R` extension) where we will write the commands. To **open our first script**, click in the menu on `File < New File < R Script`.
:::
:::

::: callout-warning
## Be careful

It is important **not to overuse the console**: everything you do not write in a script, when you close, [**you will have lost it**]{.hl-orange}.
:::

---

## Executing the first script

Now we have a **fourth window**: the window where we [**write our codes**]{.hl-yellow}. How to run it?

. . .

1. **We write** the code to execute.

. . .

2.  **Save** the .R file by clicking on `Save current document`.

. . .

3.  The code is not executed unless we tell it to do so. We have three options:

- [**Copy and paste**]{.hl-yellow} into console.
- [**Select lines**]{.hl-yellow} and `Ctrl+Enter`.
- [**Enable Source on save**]{.hl-yellow} to the right of save: it not only saves but executes the **whole code**.

---

## üíª Your turn {#tu-turno}

[**Execute your first script**: create a script from scratch, program as indicated below and execute it (in the 3 possible ways)]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

üìù Define a variable named `a` and whose value is -1.

```{r}
#| code-fold: true
a <- -1
```

### [**Exercise 2**]{.hl-yellow}

üìù Add below another line to define a variable `b` with value 5. Then multiply both variables.

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # no saved
mult <- a * b # saved
```

### [**Exercise 3**]{.hl-yellow}

üìù Modify the code below to define two variables c and d, with values 3 and -1. Then split the variables.

```{r}
#| eval: false
c <- # you should assign the value 3
d <- # you should assign the value -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d # no saved
div <- c / d # saved
```

### [**Exercise 4**]{.hl-yellow}

üìù Assign a positive value to `x` and calculate its square root; assign another negative `y` and calculate its absolute value with the `abs()` function.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

### [**Exercise 5**]{.hl-yellow}

üìù Using the variable `x` already defined, complete/modify the code below to store in a new variable `z` the result stored in `x` minus 5.

```{r}
#| eval: false
z <- ? - ? # complete the code
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```
:::

::: callout-note
## Note that...

Functions as`sqrt()`, `abs()` or `max()` are what we call [**functions**]{.hl-purple}: lines of code that we have "encapsulated" under a name, and given some input arguments, execute the commands (a kind of shortcut).

:::

---

##  Be organized: projects

In the same way that on the computer we usually work [**ordered by folders**]{.hl-yellow}, in `RStudio` we can do the same to work in [**efficient way by creating projects**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
A [**project will be a "folder "**]{.hl-yellow} inside `RStudio`, so our working directory will automatically be the project folder itself (you can switch from one project to another with the top right menu).

We can create one in a new folder or in an existing folder.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::

---

## From the VALUE to the DATABASE

What [**data type**]{.hl-yellow} can we have in each cell of a **database**?

![](img/celdas.jpg){fig-align="middle"}

::: incremental
- [**Cell (single value)**]{.hl-yellow}: single data of a specific type.
- [**Variable**]{.hl-yellow}: **concatenation** of values of the same type ([**vectors**]{.hl-purple}).
- [**Matrix**]{.hl-yellow}: concatenation of variables of **same type and length**.
- [**Data table**]{.hl-yellow}: concatenation of variables of [**different type but equal length**]{.hl-purple}.
- [**List**]{.hl-yellow}: concatenation of variables of [**different type and different length**]{.hl-purple}
:::

---

## Type of (single) data

Are there [**variables beyond numbers**]{.hl-yellow}?


. . .

Let us think, for example, of a person's stored data:

::: {.fragment .fade-up}
- The age or weight will be a [**numeric variable**]{.hl-yellow}.

```{r}
age <- 33
```
:::

::: {.fragment .fade-up}
- Its name will be a string of [**text (string or char)**]{.hl-yellow}.

```{r}
name <- "javi"
```
:::

::: {.fragment .fade-up}
- To the question "Are you single?", the answer will be what we call as a [**logical variable**]{.hl-yellow} (`TRUE` if you are single or `FALSE` otherwise).

```{r}
single <- TRUE
```
:::

::: {.fragment .fade-up}
-   Your date of birth will be just that, a [**date**]{.hl-yellow}.

:::

---

## Numeric variables

The simplest data (we have already used it) will be the [**numeric variables**]{.hl-yellow}

```{r}
#| eval: false
a <- 5
b <- 2
a + b
```

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

. . .

To know the type of a variable we have the function `class()`.

```{r}
class(a)
```

. . .

With numeric variables we can perform the [**arithmetic operations**]{.hl-yellow} of a calculator: addition (`+`), square root (`sqrt()`), square (`^2`), etc.

```{r}
a^2
abs(a)
```

---

## String variables

Let us imagine that, in addition to the age of a person, we want to store his/her name: now the variable will be of type `character`.

```{r}
name <- "Javier"
class(name)
```

. . .

[**Strings variables**]{.hl-yellow} are a type with which we obviously [**cannot perform arithmetic operations**]{.hl-red} (other operations such as pasting or locating patterns can be performed).

```{r}
#| error: true
name + 1
```

. . .

::: callout-warning
## Note that...

String variables are [**ALWAYS in quotes**]{.hl-orange}: `TRUE` (logical, binary value) is not the same as `"TRUE"` (char or string).
:::

---

## First function: paste

In `R` we denote as [**function**]{.hl-yellow} a piece of [**encapsulated code**]{.hl-yellow} under a name, and which depends on some input [**arguments**]{.hl-yellow}. Our first function will be `paste()`: given two strings, it allows us to paste them together.

```{r}
paste("Javier", "√Ålvarez")
```

. . .

Note that [**default**]{.hl-yellow} pastes strings with a space, but we can add an [**optional argument**]{.hl-yellow} to tell it the separator (in `sep = ...`).

```{r}
paste("Javier", "√Ålvarez", sep = "*")
```

---

## First function: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}
How to know [**what arguments a function needs**]{.hl-yellow}? By typing `? paste` in the console, you will get a [**help**]{.hl-yellow} in the multi-purpose panel.

In this help panel, you will see in its header what arguments the function already has [**default**]{.hl-yellow} assigned to it.
:::
:::

. . .

There is a similar function named as `paste0()` that pastes by default with `sep = ""` (without anything else).

```{r}
paste0("Javier", "√Ålvarez")
```

---

## First package: glue

A more intuitive way to work with string variables is to use the `{glue}` package: the first thing to do is to "buy the book" (if we have never done it before). After that [**load the package**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue")
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

This package allows us to use [**variables inside strings**]{.hl-yellow}. For example, "I am ... years old", where the age is stored in a variable.

```{r}
age <- 33
glue("I am {age} years old")
```

. . .

Inside brackets we can also execute operations

```{r}
units <- "days"
glue("I am {age * 365} {units} old")
```

---

## Logical conditions

Another fundamental type will be the [**logical or binary or boolean variables**]{.hl-yellow} (**just two values**):

- `TRUE`: [**true**]{.hl-yellow} stored internally as a 1.
- `FALSE`: [**false**]{.hl-yellow} stored internally as a 0.

```{r}
single <- TRUE # Are you single? --> YES
class(single)
```

. . .

It can take a third value, `NA` or [**missing data**]{.hl-yellow}, the acronym for *not available*.

. . .

::: callout-important
## Important

Logical variables [**NOT string variables**]{.hl-red}: `"TRUE"` is a string, `TRUE` is a logical value.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Logical conditions

Logical values are usually the result of [**evaluate logical conditions**]{.hl-yellow}. For example, let us imagine we want to check if my name is Javi.

```{r}
name <- "Mar√≠a"
```

. . .

The [**logical operator**]{.hl-yellow} `==` allow us to ask if left equals right.

```{r}
name == "Javi"
```

. . .

With its opposite `!=` we ask if it is different.

```{r}
name != "Javi"
```

. . .

::: callout-note
## Note that...

It is not the same `<-` ([**assignment**]{.hl-yellow}) as `==` (we are [**asking**]{.hl-yellow}, it is a logical comparison).

:::

---

## Logical conditions

In addition to "equal to" versus "different" comparisons, also order comparisons such as `<, <=, > or >=`.

**Is the person less than 32 years old?**

```{r}
age <- 38
age < 32
```

**Age is greater than or equal to 38 years old?**

```{r}
age >= 38
```


---

## Date variables

A very special data type: the [**date type data**]{.hl-yellow}.

```{r}
date_char <- "2021-04-21"
```

. . .

It looks like a simple string but [**represents an instant in time**]{.hl-yellow}. What should happen if [**we add a 1 to a date**]{.hl-purple}?

```{r}
#| error: true
date_char + 1
```

. . .

Dates [**cannot be string variables**]{.hl-red}: we must convert string variables to date with `as_date()` from the `{lubridate}` package.


```{r}
library(lubridate)
date <- as_date("2023-03-28")
date + 1
class(date)
```

---

## Date variables

In this package we have very useful functions for [**handling dates**]{.hl-yellow}:

-   `today()` allowes to directly obtain the [**current date**]{.hl-purple}.

```{r}
today()
```

. . .

-  `now()` allows to obtain [**current datetime**]{.hl-purple}

```{r}
now()
```

. . .

-  `year()`, `month()` or `day()` allows us to [**extract year, month and day**]{.hl-purple} for a given date.

```{r}
date <- today()
year(date)
month(date)
```

---

## Cheatsheets

![](img/lubridate.png)

::: callout-note
## More documentation

You have a pdf summary of the most important packages in the [**corresponding folder on campus**]{.hl-green}. See also <https://posit.co/resources/cheatsheets/>
:::

---

## üíª Your turn {#tu-turno-1}

[**Try to solve the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

üìù Define a variable that stores your age (named as `age`) and another with your name (named as `name`).

```{r}
#| code-fold: true
age <- 33
name <- "Javi"
```

### [**Exercise 2**]{.hl-yellow}

üìù Define another variable named as `siblings` that answers the question "do you have siblings?" and another one with the date of your birth (named as `birth_date`).

```{r}
#| code-fold: true
siblings <- TRUE

library(lubridate)
birth_date <- as_date("1989-09-10")
```

### [**Exercise 3**]{.hl-yellow}

üìù Define another variable with your last names (named as `surnames`) and use `glue()` to have a single variable `full_name` (separating first and last name by a comma).

```{r}
#| code-fold: true
#| eval: false
surnames <- "√Ålvarez Li√©bana"
glue("{name}, {surnames}")
```

### [**Exercise 4**]{.hl-yellow}

üìù Compute the days that have passed from the date of your birth until today (with the date of birth defined in exercise 2).

```{r}
#| code-fold: true
#| eval: false
today() - birth_date
```
:::

---

## Vectors: concatenate

Working with data usually implies having [**columns that represent variables**]{.hl-yellow}: we will call [**vectors**]{.hl-yellow} a [**concatenation**]{.hl-purple} of cells (values) of the [**same type**]{.hl-purple}.

. . .

The simplest way is using the `c()` command (c, **concatenate**), and just introduce its **elements between parentheses, and separated by commas**.

```{r}
age <- c(33, 27, 60, 61)
age
```

. . .

::: callout-tip
A single number `x <- 1` (or `x <- c(1)`) is actually a vector of length one.
:::

---

## Vectors: concatenate

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}
As you can see, in the `environment` area we have now a **collection of elements** saved

```{r}
age
```
:::
:::

. . .

The [**length of a vector**]{.hl-yellow} can be computed with `length()`.

```{r}
length(age)
```

. . .

We can also  [**concatenate vectors themselves**]{.hl-yellow}

```{r}
c(age, age, 8)
```

---

## Numerical sequences

Many times we will want to create [**numeric sequences**]{.hl-yellow} (for example, the days of the month). The `seq(start, end)` command allows us to create a **sequence** from a start element to an end element, [**advance one at a time**]{.hl-purple}.

```{r}
seq(1, 31)
```

. . .

The command `1:n` returns the same as `seq(1, n)` (if the initial element is greater than the final one, it will understand that the sequence is [**decreasing**]{.hl-purple}).

```{r}
1:5
7:-3
```

---

## Numerical sequences

We can also define [**other type of discretization step**]{.hl-yellow} between consecutives

```{r}
seq(1, 7, by = 0.5) # from 1 to 7 by step = 0.5
```

. . .

In other cases we will be interested in defining a [**sequence with a specific length**]{.hl-yellow}

```{r}
seq(1, 50, l = 7) # length 7
```

. . .

We may even want to generate a vector of [**n repeated elements**]{.hl-yellow}.

```{r}
rep(0, 7)
```

---

## Vectors: characters

A vector is a **concatenation** of [**same type**]{.hl-yellow} elements, but they do not necessarily have to be numerical types. Let us create an example sentence.

```{r}
sentence <- "I am Javi"
sentence
length(sentence)
```

. . .

In the previous case it was not a vector, it was a single text element. To create a vector we must use `c()` again and separate elements with commas.

```{r}
vector <- c("I", "am", "Javi")
vector
length(vector)
```

---

## Vectors

What will happen if we [**concatenate elements of different type**]{.hl-yellow}?

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

Notice that since they are all of the same type, what `R` does is [**convert**]{.hl-yellow} everything to character,  [**violating data integrity**]{.hl-red}

. . .

```{r}
c(3, 4, TRUE, FALSE)
```

It is important to understand that the logical values are actually [**stored internally as 0/1**]{.hl-yellow}

---

## Operating with vectors

With numeric vectors we can do the same [**arithmetic operations**]{.hl-yellow} as with numbers ‚Üí a [**number is a vector**]{.hl-purple} (of length one).

. . .

What will happen if we [**add or subtract a value**]{.hl-yellow} to a vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Be careful

Unless we indicate otherwise, in `R` operations with vectors are always [**element to element**]{.hl-orange}
:::

---

## Operating with vectors

Vectors can also interact with each other, so we can define, for example, [**sums of vectors**]{.hl-yellow} (element by element)

```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

. . .

Since the operation (e.g., a sum) is performed element by element, what will happen if [**let's add two vectors of different length**]{.hl-yellow}?

. . .

```{r}
z <- c(1, 3, 5, 7)
x + z
```

What it does is [**recycle elements**]{.hl-yellow}: if you have a vector of 4 elements and we add another one of 3 elements, it will recycle from the vector with smaller length.

---

## Operating with vectors

A very common operation is to [**ask data**]{.hl-yellow} by using [**logical conditions**]{.hl-purple}. For example, if we define a vector of temperatures....

[**What days was it less than 22 degrees**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

It will return a [**logical vector**]{.hl-yellow}, depending on whether **each element** fulfills or not the requested condition (of **equal length** to the requested vector).

. . .

If we had a [**missing data**]{.hl-yellow} (e.g., due to device error that day), the evaluated condition would also be `NA`.

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Operating with vectors

Logical [**conditions can be combined**]{.hl-yellow} in two ways:

- [**Intersection**]{.hl-yellow}: [**all**]{.hl-purple} concatenated conditions must be checked ([**conjunction and**]{.hl-purple} with `&`) to return a `TRUE`.

```{r}
x < 30 & x > 15
```

-    [**Union**]{.hl-yellow}: it is sufficient that [**at least one**]{.hl-purple} is fulfilled ([**conjunction or**]{.hl-purple} with `|`).

```{r}
x < 30 | x > 15
```

. . .

`any()` and `all()` allow us to check that [**all (or any) elements**]{.hl-yellow} meet the following criteria

```{r}
any(x < 30)
all(x < 30)
```

---

## Operating with vectors

We can also use [**statistical operations**]{.hl-yellow} such as `sum()` which, given a vector, returns the sum of all its elements.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**What happens when a single value is missing?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

By default, if we have a missing data, the [**operation will also be missing**]{.hl-yellow}. In order to [**remove that data**]{.hl-purple}, we use an optional argument `na.rm = TRUE`.

```{r}
sum(x, na.rm = TRUE)
```

---

## Operating with vectors

As we have mentioned, logical values are stored internally as 0 and 1, so we can use them in arithmetic operations.


For example, if we want to [**find the number of elements that fulfill a condition**]{.hl-yellow} (for example, "less than 3"), those that do will be assigned a 1 (`TRUE`) and those that don't a 0 (`FALSE`), so we only need to add this logical vector to obtain the number of elements that fulfill a condition.

```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Operating with vectors

Other common operations are [**average**]{.hl-yellow}, [**median**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.


- [**Average (mean)**]{.hl-yellow}: centrality measure that consists of adding all the elements and dividing by the number of elements added. The best known but the [**least robust**]{.hl-red}: given a set, if outliers (very large or very small values) are introduced, the mean is strongly perturbed.


```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Operating with vectors

Other common operations are [**average**]{.hl-yellow}, [**median**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.


-   [**Mediana**]{.hl-yellow}: measure of centrality that consists of ordering the elements and keeping the one that occupies the middle.


```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Percentiles**]{.hl-yellow}: measures of location (they divide the data into equal parts).

```{r}
quantile(x) # por defecto percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

---

## Operating with vectors

Another very common operation is to [**access elements**]{.hl-yellow} of it. The simplest way is to use the `[i]` operator (access the i-th element).

```{r}
age <- c(20, 30, 33, NA, 61) 
age[3] # third position
```

. . .


Since a number is just a vector of length one, this operation can also be applied using a [**vector of indexes to select**]{.hl-yellow}

```{r}
y <- c("Hi", "how", "are", "you", "?")
y[c(1:2, 4)] # first, second and fourth elemento
```

::: callout-tip
To access the last one, without worrying about which one, we can pass as index the length `x[length(x)]`.

:::

---

## Operating with vectors

Other times we will not want to select but [**delete some elements**]{.hl-yellow}. We will have to repeat the same operation but with the sign `-` in front: the operator `[-i]` does not select the i-th element of the vector but discards it.

```{r}
y
y[-2]
```


. . .

Many times we will want to [**select or eliminate based on logical conditions**]{.hl-yellow}, depending on the values, so we will pass as index the condition itself (remember, `x < 2` returns a logical vector).

```{r}
age <- c(15, 21, 30, 17, 45)
names <- c("javi", "mar√≠a", "laura", "carla", "luis")
names[age < 18] 
```

---

## Operating with vectors

Finally, a common action is to [**sort values**]{.hl-yellow}:

-   `sort()`: returns the [**sorted vector**]{.hl-yellow}. By default from smallest to largest but with `decreasing = TRUE` we can change it.

```{r}
age <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(age)
sort(age, decreasing = TRUE)
```

. . .

-   `order()`: returns the [**index vector**]{.hl-yellow} that we would have to use to have the sorted vector.

```{r}
order(x)
x[order(x)]
```

---

## üíª Your turn {#tu-turno-2}

[**Try to solve the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

üìù Define the vector `x` as the concatenation of the first 5 odd numbers, and calculate their sum.

```{r}
#| code-fold: true
#| eval: false
# Two ways
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

sum(x)
```

### [**Exercise 2**]{.hl-yellow}

üìù Get the elements of `x` greater than 4. Calculate the number of elements of `x` greater than 4.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
sum(x > 4)
```

### [**Exercise 3**]{.hl-yellow}

üìù Calculate the vector `1/x` and obtain the ordered version (from smallest to largest).

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Exercise 4**]{.hl-yellow}

üìù Find the maximum and minimum of vector `x`.

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Exercise 5**]{.hl-yellow}

üìù Find of the vector `x` the elements greater (strictly) than 1 and less (strictly) than 7. Find a way to find out if all the elements are positive or not.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Exercise 6**]{.hl-yellow}

üìù Given the vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extract the elements that occupy the places 1, 2, 5, 6. Removes from the vector the second element. After removing it, compute its sum and mean

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
y <- x[-2]
sum(y, na.rm = TRUE)
mean(y, na.rm = TRUE)
```
:::

---

## üê£ Case study {#caso-pr√°ctico-1}

In the `{datasets}` package we have several datasets, and one of them is named as `airquality`. I have extracted below 3 variables from this dataset

```{r}
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

1. What [**represents the data**]{.hl-yellow}? How to find out?

. . .

2. How many [**records do we have for May**]{.hl-yellow}? What about April? Construct a new `date` variable with the [**date**]{.hl-yellow} of each record (combining year, month and day).

. . .

3. Create a new variable `temp_celsius` with the [**temperature in ¬∫C**]{.hl-yellow} (units of the original variable are in Fahrenheit)

. . .

4. What was the [**average temperature**]{.hl-yellow} for the month of August? Extract the days when the [**temperature exceeded 30 degrees**]{.hl-yellow} and determine the number of days when it did.


# Lesson 2: first databases {#clase-2}

[**First databases: matrices and data.frames. Tibbles as standard type for databases. Loops vs vectorial programming. Control flow estructures**]{style="color:#444442;"}

---

## ...

# Lesson 3: tidydata {#clase-3}

[**R base vs tidyverse. Pipe operator. Principles of tidy data: tidy vs messy data. Pivoting datasets**]{style="color:#444442;"}


---

## ...
