---
title: "Data programming"
subtitle: "Data Analysis in R"
title-slide-attributes:
  data-background-image: img/data-science-2.jpeg
  data-background-size: cover
  data-background-opacity: "0.2"
author: "Master in Computational Social Sciences • 2023-2024"
affiliation: UC3M
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    chalkboard: true
    multiplex: true
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier Álvarez Liébana</strong>](...) • Master in Computational Social Sciences • 2023-2024"
    slide-number: c/t
execute:
  echo: true
---

# Welcome to R!

[**Put your spreadsheets aside**]{style="color:#444442;"}

---

## Hi!

[**Mail**]{.hl-green}: **<javiealv@pa.uc3m.es>** and **<javalv09@ucm.es>**. 

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
- [**Javier Álvarez Liébana**]{.hl-yellow} from Carabanchel (Madrid).

- Degree in Mathematics (UCM). [**PhD in Statistics**]{.hl-yellow} (UGR).

- In charge of  [**data visualization and analysis for the Principality of Asturias (2021-2022)**]{.hl-yellow} during the COVID pandemic.

- Member of the [**Spanish Society of Statistics and OR**]{.hl-yellow} and the [**Spanish Royal Mathematical Society**]{.hl-yellow}.

:::
:::
:::


. . .

Currently, [**researcher and lecturer at the Faculty of Statistics of the UCM**]{.hl-yellow}. Disseminating via [**Twitter**](https://twitter.com/dadosdelaplace) and [**Instagram**](https://instagram.com/javieralvarezliebana).

---

## Goals

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental

- Take away the [**fear of programming errors**]{.hl-yellow} → learn to program by programming

- Understanding [**basic R concepts**]{.hl-yellow} from scratch → learning to abstract ideas and algorithms

- Utility of programming → [**reproducible**, **transparent**]{.hl-yellow} and maintainable workflows.

- Introduction to [**analysis and preprocessing**]{.hl-yellow} of data → `{tidyverse}`.

- Handling [**advanced data types**]{.hl-yellow} → `{forcats}`, `{lubridate}` and `{purrr}` packages

:::
:::
:::

---

## Evaluation

- [**Attendance and individual participation**]{.hl-yellow} in the class (10%)

. . .

- [**Individual work done during the course**]{.hl-yellow} (60%). Throughout the course there are [**3 individual task submissions**]{.hl-purple}.

. . .


- [**Group work**]{.hl-yellow} done at the end of the course (30%) (between 2 and 4 people), in which the analysis of a real case must be presented.


---

## Plannning

::: column-screen-inset-right
::: {style="font-size:20px"}
|  LESSON | WEEK | DATE | TOPIC | SCRIPTS | EJ. | CASO PRÁCTICO | ENTREGA | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
|     [1](#clase-1-primeros-pasos)      | S1     | 14 sep |                 R base programming                   | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno)  [💻](#tu-turno-1) [💻](#tu-turno-2) |       [🐣](#caso-práctico-1)                  |         | 
|     [2](#clase-2)      | S2     | 26 sep |                 First databases: tibbles and tidy data       | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-3)    |  [🐣](#caso-práctico-2) [🐣](#caso-práctico-3)  |         |     
|     [3](#clase-3)      | S3    | 28 sep |     Control flow structures and rmarkdown   | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-4)      |  [🐣](#caso-práctico-3)  |         |   
|     [4](#clase-4)      | ¿?    | ¿? |        Tidyverse I   | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-4)      |  [🐣](#caso-práctico-3)  |         | 
|     [5](#clase-5)      | ¿?    | ¿? |        Tidyverse II   | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-4)      |  [🐣](#caso-práctico-3)  |         | 
|     [6](#clase-6)      | ¿?    | ¿? |        Tidyverse III   | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-4)      |  [🐣](#caso-práctico-3)  |         | 
|     [7](#clase-7)      | ¿?    | ¿? |        Advance data types and funcitons I   | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-4)      |  [🐣](#caso-práctico-3)  |    
|     [8](#clase-8)      | ¿?    | ¿? |        Advance data types and funcitons II   | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-4)      |  [🐣](#caso-práctico-3)  |   | 
|     [9](#clase-9)      | ¿?    | ¿? |        Advance data management  | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-4)      |  [🐣](#caso-práctico-3)  |         | 

:::
:::

---

## Materials

* [**Slides**]{.hl-yellow}: the slides that we will use in the classroom throughout the course, structured by classes, will be available and updated at **<https://javieralvarezliebana.es/mucss-data-programming/slides>**. 

In the slide menu (bottom left) you have an [**option to download them in pdf**]{.hl-yellow} under `Tools` (tip: do not do this until the end of the course as they will be modified).

  
&nbsp;

* [**Package summaries**]{.hl-yellow}: [**package cheatsheets**](https://github.com/dadosdelaplace/mucss-data-programming/tree/main/cheatsheets) in .pdf format


# Lesson 1: R base programming {#clase-1-primeros-pasos}

[**Introduction to R and RStudio ecosystems. Working with projects. First uses of functions and packages. Basic data types.**]{style="color:#444442;"}


---

## Requirements

For the course the only requirements will be:

1. [**Internet connection**]{.hl-yellow} (for downloading some data and packages).

2. [**Installing R**]{.hl-yellow}[: it will be our language. The download will be done (free of charge) from <https://cran.r-project.org/>]{.fragment .fade-in}


::: {.fragment .fade-in}
3.  [**Installing RStudio**]{.hl-yellow} from <https://posit.co/download/rstudio-desktop/>
:::

::: columns
::: {.column width="50%"}
![](img/cranR.jpg){width="420"}
:::

::: {.column width="50%"}
![](img/rstudio.jpg){width="420"}
:::
:::

---

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="400"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="470"}
:::
:::

::: {.fragment .fade-in-then-out}
We will program as we write (English, for example) → `R` is the [**language**]{.hl-yellow}
:::

::: {.fragment .fade-up}
- We will need a [**grammar**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}
- And an environment, for example a [**Word**]{.hl-yellow} (`RStudio`), to write it in.
:::
:::

---

## Installing R

The `R` language will be our [**grammar and spelling**]{.hl-yellow} (our rules).

::: incremental
- [**Step 1**]{.hl-yellow}: go to <https://cran.r-project.org/> and select your operating system.

- [**Step 2**]{.hl-yellow}: for Mac just click on the **.pkg file**, and open it once downloaded. For Windows systems, click on **install R for the first time** and then on **Download R for Windows**. Once downloaded, open it like any other installation file.

- [**Step 3**]{.hl-yellow}: open the installation executable.
:::

. . .

::: callout-warning
## Warning
Whenever you download something from CRAN (either R itself or a package), [**make sure you have an internet connection**]{.hl-orange}.
:::

---

## First steps

::: columns
::: {.column width="65%"}
To check that it has been installed correctly, after opening `R`, you should see a **white screen** similar to this one.

That "white screen" is called [**console**]{.hl-yellow} and we can make a first use of it as a **calculator**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="200"}
:::
:::

. . .

[**Idea**]{.hl-yellow}: let us define a variable called `a`, and it will be assigned the value `1` (type the code below in the console and hit "enter").

```{r}
#| code-line-numbers: "1"
a <- 1
```

---

## First steps

::: columns
::: {.column width="65%"}
To check that it has been installed correctly, after opening `R`, you should see a **white screen** similar to this one.

That "white screen" is called [**console**]{.hl-yellow} and we can make a first use of it as a **calculator**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Idea**]{.hl-yellow}: we will define another variable called `b` and assign it the value `2`.


```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

. . .

::: callout-note
## Note that...

In `R` we use `<-` as an arrow: the variable to the left of the arrow is assigned the value to the right (e.g. `a <- 1`).

:::

---

## First steps

::: columns
::: {.column width="65%"}
To check that it has been installed correctly, after opening `R`, you should see a **white screen** similar to this one.

That "white screen" is called [**console**]{.hl-yellow} and we can make a first use of it as a **calculator**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="270"}
:::
:::

[**Idea**]{.hl-yellow}: we will do the sum `a + b` and it will return its result.

```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```

---

## Installing R Studio

`RStudio` will be the [**Word**]{.hl-yellow} that we will use to write (what is known as an [**IDE: integrated development environment**]{.hl-yellow}).

::: incremental
- [**Step 1**]{.hl-yellow}: go to the [official RStudio website](https://posit.co/download/rstudio-desktop/) (now called Posit) and select the free download.

- [**Step 2**]{.hl-yellow}: select the executable that appears according to your operating system.

- [**Step 3**]{.hl-yellow}: after downloading the executable, open it like any other executable and let the installation finish.
:::

---

## Pane layout in RStudio

When you open `RStudio` you will probably have three windows:

- [**Console**]{.hl-yellow}: this is the name to call the big window that takes up a good part of your screen. Try writing the same code as before (the sum of the variables) in it. The console will be where we will **execute commands and show results**.

![](img/consola_rstudio.jpg){width="420"}

---

## Pane layout in RStudio

When you open `RStudio` you will probably have three windows:

-   [**Environment**]{.hl-yellow}: the small screen (you can adjust the margins) located at the upper right part. It will show us the **variables we have defined**.

![](img/environment.jpg){width="420"}

---

## Pane layout in RStudio

When you open `RStudio` you will probably have three windows:

-   [**Multi-purpose panel**]{.hl-yellow}: the window at the bottom right will not only be used to search for **function help**, but also to **view graphics**.

![](img/multiusos.jpg){width="420"}

---

## Why R?

![](img/meme_barco.jpg)

---

## Why R?

`R` is the [**main statistical language**]{.hl-yellow}, created by and for statisticians, with 5 fundamental advantages [**over Excel**]{.hl-red}:

::: incremental

- [**Programming language**]{.hl-yellow}: obviousness → [**replicable**]{.hl-purple} analysis.

- [**Free of charge**]{.hl-yellow}: the philosophy of the `R` community is code sharing under **copyleft** → [**ethical use of public money**]{.hl-purple}

- [**Open source**]{.hl-yellow}: not only is it free but it allows free access to other people's code, even to **own source code** → [**flexibility and transparency**]{.hl-purple}

- [**Modular language**]{.hl-yellow}: there are other people's code that we can reuse (almost 20 000 [**packages**]{.hl-yellow}) → [**time-saving**]{.hl-purple}

- [**High-level language**]{.hl-yellow}

:::

---

## Why R?

![](img/incel_excel.png)

---

## Why programming?

- [**Automate**]{.hl-yellow} → it will allow you to automate recurring tasks.

- [**Replicability**]{.hl-yellow} → you will be able to replicate your analysis always in the same way.

- [**Flexibility**]{.hl-yellow} → you will be able to adapt the software to your needs.

- [**Transparency**]{.hl-yellow} → it could be audited by the community.

![](img/the_general_problem.png)

---

## Main idea: packages

One of the key ideas of `R` is the [**use of packages**]{.hl-yellow}: codes that other people have implemented to **solve a problem**.

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}
- [**Installing**]{.hl-yellow}: download the codes from the web (internet required) → [**"buy a book"**]{.hl-purple}, only once (per computer)

```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}
- [**Loading**]{.hl-yellow}: after downloading the package, we indicate which packages we want to use each time we open `RStudio` → [**bring the book off the shelf**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::
:::
:::

---

## Main idea: packages

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
Once installed, there are two ways to use a package (bring it off the shelf)

::: {.fragment fragment-index="1"}
-   [**The whole package**]{.hl-yellow}: with `library()`, using the package name without quotes, we load into our session the [**whole book**]{.hl-purple}.

```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}
- [**Some particular functions**]{.hl-yellow} using `package::function` we indicate that we only want a [**concrete page of that book**]{.hl-purple}.

```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## You will be wrong

During your learning process, it is going to be very common that things don't go right the first time → [**you will make mistakes**]{.hl-yellow}. Not only will it be important to assume this, but it is [**important to read the error messages**]{.hl-yellow} to learn from them.

. . .

-   [**Error messages**]{.hl-red}: preceded by **"Error in... "** and will be those failures that [**prevent execution**]{.hl-red}.

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Warning messages**]{.hl-orange}: preceded by **"Warning in... "** are the most sensitive (possible) failures since they are inconsistencies that [**do not prevent execution**]{.hl-orange}.

```{r}
#| warning: true
# Code is ok but the result provided a NaN value, **Not A Number**, a value that is not a (real) number
sqrt(-1)
```

---

## Scripts (.R files)

::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}
A [**script**]{.hl-yellow} will be the document in which we program, our `.doc` file (here with `.R` extension) where we will write the commands. To **open our first script**, click in the menu on `File < New File < R Script`.
:::
:::

::: callout-warning
## Be careful

It is important **not to overuse the console**: everything you do not write in a script, when you close, [**you will have lost it**]{.hl-orange}.
:::

---

## Executing the first script

Now we have a **fourth window**: the window where we [**write our codes**]{.hl-yellow}. How to run it?

. . .

1. **We write** the code to execute.

. . .

2.  **Save** the .R file by clicking on `Save current document`.

. . .

3.  The code is not executed unless we tell it to do so. We have three options:

- [**Copy and paste**]{.hl-yellow} into console.
- [**Select lines**]{.hl-yellow} and `Ctrl+Enter`.
- [**Enable Source on save**]{.hl-yellow} to the right of save: it not only saves but executes the **whole code**.

---

## 💻 Your turn {#tu-turno}

[**Execute your first script**: create a script from scratch, program as indicated below and execute it (in the 3 possible ways)]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

📝 Define a variable named `a` and whose value is -1.

```{r}
#| code-fold: true
a <- -1
```

### [**Exercise 2**]{.hl-yellow}

📝 Add below another line to define a variable `b` with value 5. Then multiply both variables.

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # no saved
mult <- a * b # saved
```

### [**Exercise 3**]{.hl-yellow}

📝 Modify the code below to define two variables c and d, with values 3 and -1. Then split the variables.

```{r}
#| eval: false
c <- # you should assign the value 3
d <- # you should assign the value -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d # no saved
div <- c / d # saved
```

### [**Exercise 4**]{.hl-yellow}

📝 Assign a positive value to `x` and calculate its square root; assign another negative `y` and calculate its absolute value with the `abs()` function.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

### [**Exercise 5**]{.hl-yellow}

📝 Using the variable `x` already defined, complete/modify the code below to store in a new variable `z` the result stored in `x` minus 5.

```{r}
#| eval: false
z <- ? - ? # complete the code
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```
:::

::: callout-note
## Note that...

Functions as`sqrt()`, `abs()` or `max()` are what we call [**functions**]{.hl-purple}: lines of code that we have "encapsulated" under a name, and given some input arguments, execute the commands (a kind of shortcut).

:::

---

##  Be organized: projects

In the same way that on the computer we usually work [**ordered by folders**]{.hl-yellow}, in `RStudio` we can do the same to work in [**efficient way by creating projects**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
A [**project will be a "folder "**]{.hl-yellow} inside `RStudio`, so our working directory will automatically be the project folder itself (you can switch from one project to another with the top right menu).

We can create one in a new folder or in an existing folder.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::

---

## From the VALUE to the DATABASE

What [**data type**]{.hl-yellow} can we have in each cell of a **database**?

![](img/celdas.jpg){fig-align="middle"}

::: incremental
- [**Cell (single value)**]{.hl-yellow}: single data of a specific type.
- [**Variable**]{.hl-yellow}: **concatenation** of values of the same type ([**vectors**]{.hl-purple}).
- [**Matrix**]{.hl-yellow}: concatenation of variables of **same type and length**.
- [**Data table**]{.hl-yellow}: concatenation of variables of [**different type but equal length**]{.hl-purple}.
- [**List**]{.hl-yellow}: concatenation of variables of [**different type and different length**]{.hl-purple}
:::

---

## Type of (single) data

Are there [**variables beyond numbers**]{.hl-yellow}?


. . .

Let us think, for example, of a person's stored data:

::: {.fragment .fade-up}
- The age or weight will be a [**numeric variable**]{.hl-yellow}.

```{r}
age <- 33
```
:::

::: {.fragment .fade-up}
- Its name will be a string of [**text (string or char)**]{.hl-yellow}.

```{r}
name <- "javi"
```
:::

::: {.fragment .fade-up}
- To the question "Are you single?", the answer will be what we call as a [**logical variable**]{.hl-yellow} (`TRUE` if you are single or `FALSE` otherwise).

```{r}
single <- TRUE
```
:::

::: {.fragment .fade-up}
-   Your date of birth will be just that, a [**date**]{.hl-yellow}.

:::

---

## Numeric variables

The simplest data (we have already used it) will be the [**numeric variables**]{.hl-yellow}

```{r}
#| eval: false
a <- 5
b <- 2
a + b
```

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

. . .

To know the type of a variable we have the function `class()`.

```{r}
class(a)
```

. . .

With numeric variables we can perform the [**arithmetic operations**]{.hl-yellow} of a calculator: addition (`+`), square root (`sqrt()`), square (`^2`), etc.

```{r}
a^2
abs(a)
```

---

## String variables

Let us imagine that, in addition to the age of a person, we want to store his/her name: now the variable will be of type `character`.

```{r}
name <- "Javier"
class(name)
```

. . .

[**Strings variables**]{.hl-yellow} are a type with which we obviously [**cannot perform arithmetic operations**]{.hl-red} (other operations such as pasting or locating patterns can be performed).

```{r}
#| error: true
name + 1
```

. . .

::: callout-warning
## Note that...

String variables are [**ALWAYS in quotes**]{.hl-orange}: `TRUE` (logical, binary value) is not the same as `"TRUE"` (char or string).
:::

---

## First function: paste

In `R` we denote as [**function**]{.hl-yellow} a piece of [**encapsulated code**]{.hl-yellow} under a name, and which depends on some input [**arguments**]{.hl-yellow}. Our first function will be `paste()`: given two strings, it allows us to paste them together.

```{r}
paste("Javier", "Álvarez")
```

. . .

Note that [**default**]{.hl-yellow} pastes strings with a space, but we can add an [**optional argument**]{.hl-yellow} to tell it the separator (in `sep = ...`).

```{r}
paste("Javier", "Álvarez", sep = "*")
```

---

## First function: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}
How to know [**what arguments a function needs**]{.hl-yellow}? By typing `? paste` in the console, you will get a [**help**]{.hl-yellow} in the multi-purpose panel.

In this help panel, you will see in its header what arguments the function already has [**default**]{.hl-yellow} assigned to it.
:::
:::

. . .

There is a similar function named as `paste0()` that pastes by default with `sep = ""` (without anything else).

```{r}
paste0("Javier", "Álvarez")
```

---

## First package: glue

A more intuitive way to work with string variables is to use the `{glue}` package: the first thing to do is to "buy the book" (if we have never done it before). After that [**load the package**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue")
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

This package allows us to use [**variables inside strings**]{.hl-yellow}. For example, "I am ... years old", where the age is stored in a variable.

```{r}
age <- 33
glue("I am {age} years old")
```

. . .

Inside brackets we can also execute operations

```{r}
units <- "days"
glue("I am {age * 365} {units} old")
```

---

## Logical conditions

Another fundamental type will be the [**logical or binary or boolean variables**]{.hl-yellow} (**just two values**):

- `TRUE`: [**true**]{.hl-yellow} stored internally as a 1.
- `FALSE`: [**false**]{.hl-yellow} stored internally as a 0.

```{r}
single <- TRUE # Are you single? --> YES
class(single)
```

. . .

It can take a third value, `NA` or [**missing data**]{.hl-yellow}, the acronym for *not available*.

. . .

::: callout-important
## Important

Logical variables [**NOT string variables**]{.hl-red}: `"TRUE"` is a string, `TRUE` is a logical value.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Logical conditions

Logical values are usually the result of [**evaluate logical conditions**]{.hl-yellow}. For example, let us imagine we want to check if my name is Javi.

```{r}
name <- "María"
```

. . .

The [**logical operator**]{.hl-yellow} `==` allow us to ask if left equals right.

```{r}
name == "Javi"
```

. . .

With its opposite `!=` we ask if it is different.

```{r}
name != "Javi"
```

. . .

::: callout-note
## Note that...

It is not the same `<-` ([**assignment**]{.hl-yellow}) as `==` (we are [**asking**]{.hl-yellow}, it is a logical comparison).

:::

---

## Logical conditions

In addition to "equal to" versus "different" comparisons, also order comparisons such as `<, <=, > or >=`.

**Is the person less than 32 years old?**

```{r}
age <- 38
age < 32
```

**Age is greater than or equal to 38 years old?**

```{r}
age >= 38
```


---

## Date variables

A very special data type: the [**date type data**]{.hl-yellow}.

```{r}
date_char <- "2021-04-21"
```

. . .

It looks like a simple string but [**represents an instant in time**]{.hl-yellow}. What should happen if [**we add a 1 to a date**]{.hl-purple}?

```{r}
#| error: true
date_char + 1
```

. . .

Dates [**cannot be string variables**]{.hl-red}: we must convert string variables to date with `as_date()` from the `{lubridate}` package.


```{r}
library(lubridate)
date <- as_date("2023-03-28")
date + 1
class(date)
```

---

## Date variables

In this package we have very useful functions for [**handling dates**]{.hl-yellow}:

-   `today()` allowes to directly obtain the [**current date**]{.hl-purple}.

```{r}
today()
```

. . .

-  `now()` allows to obtain [**current datetime**]{.hl-purple}

```{r}
now()
```

. . .

-  `year()`, `month()` or `day()` allows us to [**extract year, month and day**]{.hl-purple} for a given date.

```{r}
date <- today()
year(date)
month(date)
```

---

## Cheatsheets

![](img/lubridate.png)

::: callout-note
## More documentation

You have a pdf summary of the most important packages in the [**corresponding folder on campus**]{.hl-green}. See also <https://posit.co/resources/cheatsheets/>
:::

---

## 💻 Your turn {#tu-turno-1}

[**Try to solve the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

📝 Define a variable that stores your age (named as `age`) and another with your name (named as `name`).

```{r}
#| code-fold: true
age <- 33
name <- "Javi"
```

### [**Exercise 2**]{.hl-yellow}

📝 Define another variable named as `siblings` that answers the question "do you have siblings?" and another one with the date of your birth (named as `birth_date`).

```{r}
#| code-fold: true
siblings <- TRUE

library(lubridate)
birth_date <- as_date("1989-09-10")
```

### [**Exercise 3**]{.hl-yellow}

📝 Define another variable with your last names (named as `surnames`) and use `glue()` to have a single variable `full_name` (separating first and last name by a comma).

```{r}
#| code-fold: true
#| eval: false
surnames <- "Álvarez Liébana"
glue("{name}, {surnames}")
```

### [**Exercise 4**]{.hl-yellow}

📝 Compute the days that have passed from the date of your birth until today (with the date of birth defined in exercise 2).

```{r}
#| code-fold: true
#| eval: false
today() - birth_date
```
:::

---

## Vectors: concatenate

Working with data usually implies having [**columns that represent variables**]{.hl-yellow}: we will call [**vectors**]{.hl-yellow} a [**concatenation**]{.hl-purple} of cells (values) of the [**same type**]{.hl-purple}.

. . .

The simplest way is using the `c()` command (c, **concatenate**), and just introduce its **elements between parentheses, and separated by commas**.

```{r}
age <- c(33, 27, 60, 61)
age
```

. . .

::: callout-tip
A single number `x <- 1` (or `x <- c(1)`) is actually a vector of length one.
:::

---

## Vectors: concatenate

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}
As you can see, in the `environment` area we have now a **collection of elements** saved

```{r}
age
```
:::
:::

. . .

The [**length of a vector**]{.hl-yellow} can be computed with `length()`.

```{r}
length(age)
```

. . .

We can also  [**concatenate vectors themselves**]{.hl-yellow}

```{r}
c(age, age, 8)
```

---

## Numerical sequences

Many times we will want to create [**numeric sequences**]{.hl-yellow} (for example, the days of the month). The `seq(start, end)` command allows us to create a **sequence** from a start element to an end element, [**advance one at a time**]{.hl-purple}.

```{r}
seq(1, 31)
```

. . .

The command `1:n` returns the same as `seq(1, n)` (if the initial element is greater than the final one, it will understand that the sequence is [**decreasing**]{.hl-purple}).

```{r}
1:5
7:-3
```

---

## Numerical sequences

We can also define [**other type of discretization step**]{.hl-yellow} between consecutives

```{r}
seq(1, 7, by = 0.5) # from 1 to 7 by step = 0.5
```

. . .

In other cases we will be interested in defining a [**sequence with a specific length**]{.hl-yellow}

```{r}
seq(1, 50, l = 7) # length 7
```

. . .

We may even want to generate a vector of [**n repeated elements**]{.hl-yellow}.

```{r}
rep(0, 7)
```

---

## Vectors: characters

A vector is a **concatenation** of [**same type**]{.hl-yellow} elements, but they do not necessarily have to be numerical types. Let us create an example sentence.

```{r}
sentence <- "I am Javi"
sentence
length(sentence)
```

. . .

In the previous case it was not a vector, it was a single text element. To create a vector we must use `c()` again and separate elements with commas.

```{r}
vector <- c("I", "am", "Javi")
vector
length(vector)
```

---

## Vectors

What will happen if we [**concatenate elements of different type**]{.hl-yellow}?

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

Notice that since they are all of the same type, what `R` does is [**convert**]{.hl-yellow} everything to character,  [**violating data integrity**]{.hl-red}

. . .

```{r}
c(3, 4, TRUE, FALSE)
```

It is important to understand that the logical values are actually [**stored internally as 0/1**]{.hl-yellow}

---

## Operating with vectors

With numeric vectors we can do the same [**arithmetic operations**]{.hl-yellow} as with numbers → a [**number is a vector**]{.hl-purple} (of length one).

. . .

What will happen if we [**add or subtract a value**]{.hl-yellow} to a vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Be careful

Unless we indicate otherwise, in `R` operations with vectors are always [**element to element**]{.hl-orange}
:::

---

## Operating with vectors

Vectors can also interact with each other, so we can define, for example, [**sums of vectors**]{.hl-yellow} (element by element)

```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

. . .

Since the operation (e.g., a sum) is performed element by element, what will happen if [**let's add two vectors of different length**]{.hl-yellow}?

. . .

```{r}
z <- c(1, 3, 5, 7)
x + z
```

What it does is [**recycle elements**]{.hl-yellow}: if you have a vector of 4 elements and we add another one of 3 elements, it will recycle from the vector with smaller length.

---

## Operating with vectors

A very common operation is to [**ask data**]{.hl-yellow} by using [**logical conditions**]{.hl-purple}. For example, if we define a vector of temperatures....

[**What days was it less than 22 degrees**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

It will return a [**logical vector**]{.hl-yellow}, depending on whether **each element** fulfills or not the requested condition (of **equal length** to the requested vector).

. . .

If we had a [**missing data**]{.hl-yellow} (e.g., due to device error that day), the evaluated condition would also be `NA`.

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Operating with vectors

Logical [**conditions can be combined**]{.hl-yellow} in two ways:

- [**Intersection**]{.hl-yellow}: [**all**]{.hl-purple} concatenated conditions must be checked ([**conjunction and**]{.hl-purple} with `&`) to return a `TRUE`.

```{r}
x < 30 & x > 15
```

-    [**Union**]{.hl-yellow}: it is sufficient that [**at least one**]{.hl-purple} is fulfilled ([**conjunction or**]{.hl-purple} with `|`).

```{r}
x < 30 | x > 15
```

. . .

`any()` and `all()` allow us to check that [**all (or any) elements**]{.hl-yellow} meet the following criteria

```{r}
any(x < 30)
all(x < 30)
```

---

## Operating with vectors

We can also use [**statistical operations**]{.hl-yellow} such as `sum()` which, given a vector, returns the sum of all its elements.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**What happens when a single value is missing?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

By default, if we have a missing data, the [**operation will also be missing**]{.hl-yellow}. In order to [**remove that data**]{.hl-purple}, we use an optional argument `na.rm = TRUE`.

```{r}
sum(x, na.rm = TRUE)
```

---

## Operating with vectors

As we have mentioned, logical values are stored internally as 0 and 1, so we can use them in arithmetic operations.


For example, if we want to [**find the number of elements that fulfill a condition**]{.hl-yellow} (for example, "less than 3"), those that do will be assigned a 1 (`TRUE`) and those that don't a 0 (`FALSE`), so we only need to add this logical vector to obtain the number of elements that fulfill a condition.

```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Operating with vectors

Other common operations are [**average**]{.hl-yellow}, [**median**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.


- [**Average (mean)**]{.hl-yellow}: centrality measure that consists of adding all the elements and dividing by the number of elements added. The best known but the [**least robust**]{.hl-red}: given a set, if outliers (very large or very small values) are introduced, the mean is strongly perturbed.


```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Operating with vectors

Other common operations are [**average**]{.hl-yellow}, [**median**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.


-   [**Median**]{.hl-yellow}: measure of centrality that consists of ordering the elements and keeping the one that occupies the middle.


```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Percentiles**]{.hl-yellow}: measures of location (they divide the data into equal parts).

```{r}
quantile(x) # por defecto percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

---

## Operating with vectors

Another very common operation is to [**access elements**]{.hl-yellow} of it. The simplest way is to use the `[i]` operator (access the i-th element).

```{r}
age <- c(20, 30, 33, NA, 61) 
age[3] # third position
```

. . .


Since a number is just a vector of length one, this operation can also be applied using a [**vector of indexes to select**]{.hl-yellow}

```{r}
y <- c("Hi", "how", "are", "you", "?")
y[c(1:2, 4)] # first, second and fourth elemento
```

::: callout-tip
To access the last one, without worrying about which one, we can pass as index the length `x[length(x)]`.

:::

---

## Operating with vectors

Other times we will not want to select but [**delete some elements**]{.hl-yellow}. We will have to repeat the same operation but with the sign `-` in front: the operator `[-i]` does not select the i-th element of the vector but discards it.

```{r}
y
y[-2]
```


. . .

Many times we will want to [**select or eliminate based on logical conditions**]{.hl-yellow}, depending on the values, so we will pass as index the condition itself (remember, `x < 2` returns a logical vector).

```{r}
age <- c(15, 21, 30, 17, 45)
names <- c("javi", "maría", "laura", "carla", "luis")
names[age < 18] 
```

---

## Operating with vectors

Finally, a common action is to [**sort values**]{.hl-yellow}:

-   `sort()`: returns the [**sorted vector**]{.hl-yellow}. By default from smallest to largest but with `decreasing = TRUE` we can change it.

```{r}
age <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(age)
sort(age, decreasing = TRUE)
```

. . .

-   `order()`: returns the [**index vector**]{.hl-yellow} that we would have to use to have the sorted vector.

```{r}
order(x)
x[order(x)]
```

---

## 💻 Your turn {#tu-turno-2}

[**Try to solve the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

📝 Define the vector `x` as the concatenation of the first 5 odd numbers, and calculate their sum.

```{r}
#| code-fold: true
#| eval: false
# Two ways
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

sum(x)
```

### [**Exercise 2**]{.hl-yellow}

📝 Get the elements of `x` greater than 4. Calculate the number of elements of `x` greater than 4.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
sum(x > 4)
```

### [**Exercise 3**]{.hl-yellow}

📝 Calculate the vector `1/x` and obtain the ordered version (from smallest to largest).

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Exercise 4**]{.hl-yellow}

📝 Find the maximum and minimum of vector `x`.

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Exercise 5**]{.hl-yellow}

📝 Find of the vector `x` the elements greater (strictly) than 1 and less (strictly) than 7. Find a way to find out if all the elements are positive or not.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Exercise 6**]{.hl-yellow}

📝 Given the vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extract the elements that occupy the places 1, 2, 5, 6. Removes from the vector the second element. After removing it, compute its sum and mean

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
y <- x[-2]
sum(y, na.rm = TRUE)
mean(y, na.rm = TRUE)
```
:::

---

## 🐣 Case study {#caso-práctico-1}

In the `{datasets}` package we have several datasets, and one of them is named as `airquality`. I have extracted below 3 variables from this dataset

```{r}
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

1. What [**represents the data**]{.hl-yellow}? How to find out?

. . .

2. How many [**records do we have for May**]{.hl-yellow}? What about April? Construct a new `date` variable with the [**date**]{.hl-yellow} of each record (combining year, month and day).

. . .

3. Create a new variable `temp_celsius` with the [**temperature in ºC**]{.hl-yellow} (units of the original variable are in Fahrenheit)

. . .

4. What was the [**average temperature**]{.hl-yellow} for the month of August? Extract the days when the [**temperature exceeded 30 degrees**]{.hl-yellow} and determine the number of days when it did.


# Lesson 2: first databases {#clase-2}

[**First databases: tibbles as standard type for databases. R base vs tidyverse. Pipe operator. Principles of tidy data: tidy vs messy data. Pivoting datasets**]{style="color:#444442;"}

---


## First attempt: matrices

In data science we usually have [**several variables**]{.hl-yellow} for each individual: we need a "table" to collect them. The most immediate option is [**matrices**]{.hl-yellow}: a concatenation of variables of [**same type and equal length**]{.hl-purple}.

. . .

Let us imagine that we have heights and weights of 4 people. How to [**create a dataset with those variables**]{.hl-yellow}?


-   Function `cbind()` allow us to [**concatenate vectors by columns**]{.hl-yellow}

```{r}
heights <- c(150, 160, 170, 180)
weights <- c(63, 70, 85, 95)
data_matrix <- cbind(heights, weights)
data_matrix
```

---

## First attempt: matrices

- We can also [**define a matrix by rows**]{.hl-yellow} with the `rbind()` function (although it is recommended to have each variable in column and individuals in row).

```{r}
rbind(heights, weights)
```

- We can [**view the matrix**]{.hl-yellow} (in a tabular way) using the function `View()`.

. . .

- We can [**check dimensions**]{.hl-yellow} with `dim()`, `nrow()` and `ncol()` (data is now tabulated).

```{r}
dim(data_matrix)
nrow(data_matrix)
```

---

## First attempt: matrices

- We can also [**transpose a matrix**]{.hl-yellow} with `t()`.

```{r}
t(data_matrix)
```

. . .

- Since we now have two dimensions, to [**access elements**]{.hl-yellow} we must provide the index of the row and column inside of brackets (if they are free, it implies all of that dimension)

```{r}
data_matrix[2, 1]
data_matrix[, 2]
```

---

## First attempt: matrices

- We can also define a [**matrix from a numeric vector**]{.hl-yellow}, reorganizing the values in the form of a matrix (knowing that the elements are **placed by columns**).

```{r}
z <- matrix(1:15, ncol = 5) 
z
```

. . .

With matrices it is the same as with vectors: when we apply an [**arithmetic operation, we do it element by element**]{.hl-yellow}

```{r}
z/5
```

---

## First attempt: matrices

We can also apply [**apply functions by columns/rows**]{.hl-yellow} (avoiding loops) with `apply()`, taking as **input arguments**

- a matrix
- the sense (`MARGIN = 1` by rows, `MARGIN = 2` by columns)
- a function to be applied.

. . .

```{r}
# Mean by columns (MARGIN = 2)
apply(data_matrix, MARGIN = 2, FUN = "mean")

# (Quasi)var (var) by columns (MARGIN = 2)
apply(data_matrix, MARGIN = 2, FUN = "var")
```

. . .

[**We won't go deeper**]{.hl-red} any further since our goal is to have variables of the same length but [**different types**]{.hl-yellow} (but know they exist).

---

## 💻 Your turn (matrices) {#tu-turno-matrices}

[**Try to solve the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

📝 Modify the code below to define an `x` matrix of ones with 3 rows and 7 columns.

```{r}
#| eval: false
x <- matrix(0, nrow = 2, ncol = 3)
x
```

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1, nrow = 3, ncol = 7)
x
```

### [**Exercise 2**]{.hl-yellow}

📝 Add a 1 to each number in the matrix above, and divide the result by 5. After that, calculate its transpose and obtain its dimensions

```{r}
#| code-fold: true
#| eval: false
new_matrix <- (x + 1)/5
t(new_matrix)
dim(new_matrix)
```

### [**Exercise 3**]{.hl-yellow}

📝 Define matrix `x <- matrix(1:12, nrow = 4)`. Get the first row, the third column, and the element (4, 1).

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
x[1, ] # first row
x[, 3] # third column
x[4, 1] # element (4, 1)
```

### [**Exercise 4**]{.hl-yellow}

📝 With the above matrix defined as `x <- matrix(1:12, nrow = 4)`, calculate the mean of all elements, the mean of each row and the mean of each column. Calculate the sum of each row and each column.

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
mean(x) # mean (of all elements)
apply(x, MARGIN = 1, FUN = "mean") # mean by rows
apply(x, MARGIN = 2, FUN = "mean") # mean by columns
apply(x, MARGIN = 1, FUN = "sum") # sum by rows
apply(x, MARGIN = 2, FUN = "sum") # sum by columns

```
:::

---

## Second attempt: data.frame

Matrices have the same problem as vectors: if we collect data of different types together, [**data integrity is compromised**]{.hl-red} as it converts them into.

```{r}
#| code-line-numbers: "4-5"
ages <- c(14, 24, NA)
single <- c(TRUE, NA, FALSE)
names <- c("javi", "laura", "lucía")
matrix <- cbind(ages, single, names)
matrix
```

. . .

Since we are no longer numbers, we cannot perform arithmetic operations.

```{r}
#| error: true
matrix + 1
```

---

## Second attempt: data.frame

In order to work with [**variables of different type**]{.hl-yellow} we have what is known as [**data.frame**]{.hl-yellow}: concatenation of variables of equal length but may be of [**different type**]{.hl-purple}.

```{r}
#| code-line-numbers: "1"
table <- data.frame(ages, single, names)
class(table)
table
```

---

## Second attempt: data.frame

Since a `data.frame` is already a `database` the variables are not mere mathematical vectors: [**they have a meaning**]{.hl-yellow} and we can (must) [**name them**]{.hl-purple}.

```{r}
library(lubridate)
table <- data.frame("ags" = ages, "single" = single, "name" = names,
             "b_date" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
table
```

---

## Second attempt: data.frame

[**We have our first dataset!**]{.hl-yellow} You can view it by typing its name in the console or with `View(table)`.

![](img/view_tabla.jpg)

---

## Second attempt: data.frame

If we want to access its elements, we can, as in matrices (although it is not recommended): now [**we have two indexes**]{.hl-yellow} (rows and columns, leaving free the one we don't use)

```{r}
table[2, ]  # second row (all variables)
table[, 3]  # third column (all individuals)
table[2, 1]  # first variable for the second individual
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
It also has advantages of a [**database**]{.hl-yellow} : we can [**access variables by name**]{.hl-purple} (**recommendable** since variables can change position), putting the name of the table followed by the symbol `$` (with the **tab**, a menu of columns to choose from will appear).
:::
:::

---

## Second attempt: data.frame

- `names()`: show us the names of the variables.

```{r}
names(table)
```

. . .

- `dim()`: show us the dimensions (see also `nrow()` and `ncol()`)

```{r}
dim(table)
```

. . .

-  We can access to variables by name

```{r}
table[c(1, 3), "name"]
```

---

## Second attempt: data.frame

If we have one already created and we want to [**add a column**]{.hl-yellow} it is as simple as using the `data.frame()` function we have already seen to concatenate the column. Let's add for example a new variable, the number of siblings of each individual.

```{r}
# Add new column
siblings <- c(0, 2, 3)
table <- data.frame(table, "n_sib" = siblings)
table
```

---

## Final attempt: tibble

Tables in `data.frame` format have some [**limitations**]{.hl-red}

The main one is that [**does not allow recursion**]{.hl-red}: imagine we define a database with heights and weights, and we want a third variable with BMI.

```{r}
#| error: true
data.frame("height" = c(1.7, 1.8, 1.6), "weight" = c(80, 75, 70),
           "BMI" = weight / (height^2))
```

. . .

From now on we will use the `tibble` format (an [**enhanced data.frame**]{.hl-yellow}).

```{r}
library(tibble)
tibble("height" = c(1.7, 1.8, 1.6), "weight" = c(80, 75, 70),
       "BMI" = weight / (height^2))
```

---

## Final attempt: tibble

```{r}
table <- tibble("height" = c(1.7, 1.8, 1.6), "weight" = c(80, 75, 70),
                "BMI" = weight / (height^2))
table
```

Tables in `tibble` format will allow a [**more agile, efficient and coherent**]{.hl-yellow} data management, with 4 main advantages:

. . .

- [**Metainfo**]{.hl-yellow}: if you look at the header, it automatically tells us the number of rows and columns, and the type of each variable.

. . .

- [**Recursivity**]{.hl-yellow}: allows you to define the variables sequentially (as we have seen).

---

## Final attempt: tibble

- [**Consistency**]{.hl-yellow}: if you access a column that does not exist, a warning message is issued.

```{r}
#| warning: true
table$invent
```

. . .

- [**By rows**]{.hl-yellow}: create by rows (copy and paste from a table) with `tribble()`.

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
## Tip
The `{datapasta}` package allows us to [**copy and paste**]{.hl-green} tables from web pages and simple documents.
:::


---

## 💻 Your turn (tibble) {#tu-turno-tibble}

[**Try to solve the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset

### [**Exercise 1**]{.hl-yellow}

📝 Load from the `{datasets}` package the `airquality` dataset (New York air quality variables from May through September 1973). Is the airquality dataset of type tibble? If not, convert it to tibble (look in the package documentation at <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Exercise 2**]{.hl-yellow}

📝 Once converted into `tibble` get the name of the variables and the dimensions of the data set. How many variables are there? How many days have been measured?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```

### [**Exercise 3**]{.hl-yellow}

📝 Filters only data for the month of August.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, ]
```

### [**Exercise 4**]{.hl-yellow}

📝 Select those data that are not from July or August.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[!(airquality_tb$Month %in% c(7, 8)), ]
```

### [**Exercise 5**]{.hl-yellow}

📝 Modify the following code to keep only the ozone and temperature variables.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[, c("Ozone", "Temp")]
```

### [**Exercise 6**]{.hl-yellow}

📝 Select the temperature and wind data for August. Translate the name of the columns of the filtered set to your motherlanguage.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, c("Temp", "Wind")]
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```
:::

---

## Summary

- Each [**cell can be of a different type**]{.hl-yellow}: numbers, text, dates, logical values, etc.

. . .

- A [**vector is a concatenation of cells**]{.hl-yellow} (columns of our tables) --> In `R` by default the operations are done [**element by element**]{.hl-yellow}

. . .

- A [**matrix**]{.hl-yellow} allows us to concatenate [**variables of the SAME type and SAME length**]{.hl-yellow} --> two-dimensional object (two indices)

. . .

- A [**data.frame**]{.hl-yellow} allows us to concatenate [**variables of DIFFERENT type and SAME length**]{.hl-yellow} --> we will use [**tibble**]{.hl-yellow} as an enhanced database option.

---

## 🐣 Case study {#caso-práctico-2}

From the `{Biostatistics}` package we will use the `pinniped` data set.

```{r}
#| eval: false
Biostatistics::pinniped
```

1. What [**data type**]{.hl-yellow} does the data represent? What [**data type**]{.hl-yellow} is it? If not, convert the database to a `tibble` (rename with `pinniped_tb`).

. . .

2. How many records are there, and variables, what type is each one?

. . .

3. Incorporate an [**extra variable named phoca**]{.hl-yellow} that is of logical type and check whether a species is of category `Phoca` or not.

. . .

4. Which sex is [**weighted more by brain**]{.hl-yellow}: females or males? Who is [**weighted more by body**]{.hl-yellow}: monogamous or polygamous?

. . .

5. Add a new variable representing the [**difference in brain weight between males and females**]{.hl-yellow} (males - females) for each species.


---

## R base vs Tidyverse

If you know any other programming language, you will be surprised that we have not yet talked about common concepts such as

- [**For loops**]{.hl-yellow}: repeat a code a fixed number of iterations.

- [**while loops**]{.hl-yellow}: repeat a code until a condition is verified.

- [**if-else structures**]{.hl-yellow}: control flow structures to decide where the code walks depending on the value of variables.

. . .

And although knowing these structures can be interesting at some point, in [**most of the times we will be able to avoid them**]{.hl-red} (specially loops).

---

## What about tidyverse?

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

`{tidyverse}` is an [**"universe" of packages**]{.hl-yellow} to ensure an efficient, coherent and lexicographically simple to understand workflow based on the idea that [**our data is clean and tidy**]{.hl-purple}

---

## What about tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
- `{tibble}`: optimizing data.frame
- `{tidyr}`: data cleaning
- `{readr}`: loading rectangular data (.csv)
- `{dplyr}`: grammar for debugging
- `{stringr}`: text handling
- `{ggplot2}`: data visualization
- `{tidymodels}`: modeling/prediction
:::
:::

We also have the `{purrr}` packages for list management, `{forcast}` for qualitative variables, `{lubridate}` for dates, `{readxl}` for importing .xls and .xlsx files, `{rvest}` for web scraping and `{rmarkdown}` for reporting results.

---

## What about tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizing data.frame**]{.hl-yellow}
-   `{tidyr}`: [**data cleaning**]{.hl-yellow}
- `{readr}`: loading rectangular data (.csv)
- `{dplyr}`: grammar for debugging
- `{stringr}`: text handling
- `{ggplot2}`: data visualization
- `{tidymodels}`: modeling/prediction
:::
:::

We also have the `{purrr}` packages for list management, `{forcast}` for qualitative variables, `{lubridate}` for dates, `{readxl}` for importing .xls and .xlsx files, `{rvest}` for web scraping and `{rmarkdown}` for reporting results.

---

## Idea: Tidy Data

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

::: {style="font-size:120px; text-align: center; color:#F8DF58;"}
<b>TIDY</b><b>[VERSE</b>]{style="color:#CAB0EE;"}
:::

The [**universe**]{.hl-purple} of `{tidyverse}` packages is based on the idea introduced by **Hadley Wickham** (the God I pray to) of [**standardize**]{.hl-yellow} formatting data to

::: incremental
- [**systematize**]{.hl-green} debugging
- make it [**simpler**]{.hl-green} to manipulate.
- [**readable**]{.hl-green} code.
:::

---

## Tidy data: rules

The first thing will therefore be to understand what the [**tidydata sets**]{.hl-yellow} are, since the whole `{tidyverse}` is based on the data being standardized.

::: columns
::: {.column width="50%"}
::: {.fragment .fade-in}
1. Each [**variable**]{.hl-yellow} in a [**single column**]{.hl-purple}
:::

::: {.fragment .fade-in}
2.  Each [**individual**]{.hl-yellow} in a [**different row**]{.hl-purple}
:::

::: {.fragment .fade-in}
3.  Each [**cell**]{.hl-yellow} with a [**single value**]{.hl-purple}
:::

::: {.fragment .fade-in}
4.  Each [**dataset**]{.hl-yellow} in a [**tibble**]{.hl-purple}
:::

::: {.fragment .fade-in}
5.  If we want to cross [**multiple tables**]{.hl-yellow} we must have a [**common (key) column**]{.hl-purple}
:::
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
:::

---

## Pipe operator

In `{tidyverse}` the [**pipe operator**]{.hl-yellow}, defined as `|>` ([**ctrl+shift+M**]{.hl-purple}), will be key: it will be a [**pipe that traverses the data**]{.hl-yellow} and transforms it.

. . .

::: columns
::: {.column width="50%"}
In R base, if we want to apply three functions `first()`, `second()` and `third()` in order, it would be

```{r}
#| eval: false
third(second(first(data)))
```
:::

::: {.column width="50%"}
In `{tidyverse}` we can [**read from left to right**]{.hl-yellow} and separate the data from the actions

```{r}
#| eval: false
data |> first() |> second() |> third()
```
:::
:::


. . .

::: callout-caution
## Note that...

Since version 4.1.0 of `R` we have `|>`, a **native** pipe available [**outside tidyverse**]{.hl-purple}, replacing the [**old pipe**]{.hl-red} `%>%` which depended on the `{magrittr}` package (quite problematic).
:::

---

## Pipe operator

The main advantage is that the [**code is very readable (almost literal)**]{.hl-yellow} and you can do large operations on the data with very little code.

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  tidy(...) |>
  filter(...) |>
  select(...) |>
  arrange(...) |>
  modify(...) |>
  rename(...) |>
  group(...) |>
  count(...) |>
  summary(...) |>
  plot(...)
```
:::

::: {.column width="50%"}
<center><img src="img/logo_pipe.png" width="360px"/></center>
:::
:::

---

## Messy data

But what does the [**non-tidy data**]{.hl-yellow} look like? Let's load the `table4a` table from the `{tidyr}` package (we already have it loaded from the tidyverse environment).


```{r}
library(tidyr)
table4a
```


[**What could be wrong?**]{.hl-red}

---

## Pivoting: pivot_longer()

::: columns
::: {.column width="40%"}
```{r}
table4a
```
:::

::: {.column width="60%"}
❎ Each [**row represents two observations**]{.hl-red} (1999 and 2000) → columns `1999` and `2000` should actually themselves be [**values of a variable**]{.hl-yellow} and not column names.
:::
:::

. . .

We will include a [**new column**]{.hl-yellow} that stores the year and another one that stores the value of the variable of interest in each of those years. And we will do it with the `pivot_longer()` function: [**pivot the table**]{.hl-yellow} to long format

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

---

## Pivoting: pivot_longer()

::: columns
::: {.column width="50%"}
```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year",
               values_to = "cases")
```
:::

::: {.column width="50%"}
![](img/table4a.jpg)
:::
:::


- `cols`: [**name of the variables to be pivoted**]{.hl-yellow}
- `names_to`: name of the new variable to which we send the [**header**]{.hl-yellow} of the table (the names).
- `values_to`: name of the new variable to which we are going to send the [**data**]{.hl-yellow}.

---

## Messy data

Let us see another example in `table2`


```{r}
table2
```


[**What could be wrong?**]{.hl-red}

---

## Pivoting: pivot_wider()

::: columns
::: {.column width="60%"}
```{r}
#| echo: false
table2
```
:::

::: {.column width="40%"}
❎ Each [**observation is divided into two rows**]{.hl-red} → the [**records with the same year should be the same**]{.hl-yellow}
:::
:::

. . .

We will do will be the opposite: with `pivot_wider()` [**we will widen the table**]{.hl-yellow}

```{r}
table2 |>  pivot_wider(names_from = type, values_from = count)
```

---

## Messy data

Let us see another example in `table3`


```{r}
table3
```


[**What could be wrong?**]{.hl-red}

---

## separate()

::: columns
::: {.column width="60%"}
```{r}
table3
```
:::

::: {.column width="40%"}
❎ Each [**cell contains several values**]{.hl-red}
:::
:::

. . .

What we will do is make use of the `separate()` function to send [**separate each value**]{.hl-yellow} to a different column.

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

---

## separate()

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

Notice that the data, although it has separated them, [**kept them as text**]{.hl-red} when in fact they should be numeric variables. For this we can add the optional argument `convert = TRUE`.
. . .

```{r}
table3 |> separate(rate, into = c("cases", "pop"), convert = TRUE)
```

---

## Messy data

Let us see the last example in `table5`


```{r}
table5
```


[**What could be wrong?**]{.hl-red}

---

## unite()

::: columns
::: {.column width="50%"}
```{r}
table5
```
:::

::: {.column width="50%"}
❎ We have [**same values divided into two columns**]{.hl-red}
:::
:::

. . .

We will use `unite()` to [**unite the values**]{.hl-yellow} of century and year in the same column

```{r}
table5 |> unite(col = year_whole, century, year, sep = "")
```

---

## 💻 Tu turno {#tu-turno-3}


[**Try to solve the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset

### [**Exercise 1**]{.hl-yellow}

📝 Take a look at table `table4b` in package `{tidyr}`. Is it tidydata? If not, what is wrong, how to convert it to tidy data in case it is not already?

```{r}
#| code-fold: true
#| eval: false
table4b |>
  pivot_longer(cols = "1999":"2000", names_to = "year",
               values_to = "cases")
```

### [**Exercise 2**]{.hl-yellow}

📝 Take a look at table `relig_income` in package `{tidyr}`. Is it tidydata? If not, what is wrong, how to convert it to tidy data in case it is not already?

```{r}
#| code-fold: true
#| eval: false
relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused",
               names_to = "income",
               values_to = "people")
```

### [**Exercise 3**]{.hl-yellow}

📝 Take a look at table `billboard` in package `{tidyr}`. Is it tidydata? If not, what is wrong, how to convert it to tidy data in case it is not already?

```{r}
#| code-fold: true
#| eval: false
billboard |>
  pivot_longer(cols = "wk1":"wk76",
               names_to = "week",
               names_prefix = "wk",
               values_to = "position",
               values_drop_na = TRUE)
```

:::

---

## 🐣 Case study {#caso-práctico-3}

In the `{tidyr}` package we have the `who` dataset (World Health Organization dataset).

```{r}
#| eval: false
library(tidyr)
who
```


1. What do [**data**]{.hl-yellow} mean? How many [**variables and observations**]{.hl-yellow} do we have?

. . .

2. How many [**variable types**]{.hl-yellow} do we have?

. . .

3. Are all variables necessary? [**Remove redundant information**]{.hl-yellow}.

. . .

4. [**Convert to tidydata**]{.hl-yellow} the database by making all the options you consider (tip: use paper to sketch how the database should look like).



# Lesson 3: control flow structures and rmd {#clase-3}

[**Loops vs vectorial programming. Control flow estructures. Rmarkdown and Quarto**]{style="color:#444442;"}


---

## ...
