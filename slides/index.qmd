---
title: "Data programming"
subtitle: "Data Analysis in R"
title-slide-attributes:
  data-background-image: img/data-science-2.jpeg
  data-background-size: cover
  data-background-opacity: "0.2"
author: "Master in Computational Social Sciences • 2023-2024"
affiliation: UC3M
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    chalkboard: true
    multiplex: true
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier Álvarez Liébana</strong>](...) • Master in Computational Social Sciences • 2023-2024"
    slide-number: c/t
execute:
  echo: true
---

# Welcome to R!

[**Put your spreadsheets aside**]{style="color:#444442;"}

---

## Hi!

[**Mail**]{.hl-green}: **<javiealv@pa.uc3m.es>** and **<javalv09@ucm.es>**. 

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
- [**Javier Álvarez Liébana**]{.hl-yellow} from Carabanchel (Madrid).

- Degree in Mathematics (UCM). [**PhD in Statistics**]{.hl-yellow} (UGR).

- In charge of  [**data visualization and analysis for the Principality of Asturias (2021-2022)**]{.hl-yellow} during the COVID pandemic.

- Member of the [**Spanish Society of Statistics and OR**]{.hl-yellow} and the [**Spanish Royal Mathematical Society**]{.hl-yellow}.

:::
:::
:::


. . .

Currently, [**researcher and lecturer at the Faculty of Statistics of the UCM**]{.hl-yellow}. Disseminating via [**Twitter**](https://twitter.com/dadosdelaplace) and [**Instagram**](https://instagram.com/javieralvarezliebana).

---

## Goals

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental

- Take away the [**fear of programming errors**]{.hl-yellow} → learn to program by programming

- Understanding [**basic R concepts**]{.hl-yellow} from scratch → learning to abstract ideas and algorithms

- Utility of programming → [**reproducible**, **transparent**]{.hl-yellow} and maintainable workflows.

- Introduction to [**analysis and preprocessing**]{.hl-yellow} of data → `{tidyverse}`.

- Handling [**advanced data types**]{.hl-yellow} → `{forcats}`, `{lubridate}` and `{purrr}` packages

:::
:::
:::

---

## Evaluation

- [**Attendance and individual participation**]{.hl-yellow} in the class (10%)

. . .

- [**Individual work done during the course**]{.hl-yellow} (60%). Throughout the course there are [**3 individual task submissions**]{.hl-purple}.

. . .


- [**Group work**]{.hl-yellow} done at the end of the course (30%) (between 2 and 4 people), in which the analysis of a real case must be presented.


---

## Plannning

::: column-screen-inset-right
::: {style="font-size:20px"}
|  LESSON | WEEK | DATE | TOPIC | SCRIPTS | EJ. | CASO PRÁCTICO | ENTREGA | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
|     [1](#clase-1-primeros-pasos)      | S1     | 14 sep |                 R base programming                   | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno)  [💻](#tu-turno-1) [💻](#tu-turno-2) |       [🐣](#caso-práctico-1)                  |         | 
|     [2](#clase-2)      | S2     | 26 sep |                 First databases: tibbles and tidy data       | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-3)    |  [🐣](#caso-práctico-2)  |         |     
|     [3](#clase-3)      | S3    | 28 sep |     Control flow structures and rmarkdown   | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-4)      |  [🐣](#caso-práctico-3)  |         |   
|     [4](#clase-4)      | ¿?    | ¿? |        Tidyverse I   | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-4)      |  [🐣](#caso-práctico-3)  |         | 
|     [5](#clase-5)      | ¿?    | ¿? |        Tidyverse II   | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-4)      |  [🐣](#caso-práctico-3)  |         | 
|     [6](#clase-6)      | ¿?    | ¿? |        Tidyverse III   | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-4)      |  [🐣](#caso-práctico-3)  |         | 
|     [7](#clase-7)      | ¿?    | ¿? |        Advance data types and funcitons I   | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-4)      |  [🐣](#caso-práctico-3)  |    
|     [8](#clase-8)      | ¿?    | ¿? |        Advance data types and funcitons II   | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-4)      |  [🐣](#caso-práctico-3)  |   | 
|     [9](#clase-9)      | ¿?    | ¿? |        Advance data management  | [📝](https://github.com/dadosdelaplace/mucss-data-programming/material/scripts)  |       [💻](#tu-turno-4)      |  [🐣](#caso-práctico-3)  |         | 

:::
:::

---

## Materials

* [**Slides**]{.hl-yellow}: the slides that we will use in the classroom throughout the course, structured by classes, will be available and updated at **<https://javieralvarezliebana.es/mucss-data-programming/slides>**. 

In the slide menu (bottom left) you have an [**option to download them in pdf**]{.hl-yellow} under `Tools` (tip: do not do this until the end of the course as they will be modified).

  
&nbsp;

* [**Package summaries**]{.hl-yellow}: [**package cheatsheets**](https://github.com/dadosdelaplace/mucss-data-programming/tree/main/cheatsheets) in .pdf format


# Lesson 1: R base programming {#clase-1-primeros-pasos}

[**Introduction to R and RStudio ecosystems. Working with projects. First uses of functions and packages. Basic data types.**]{style="color:#444442;"}


---

## Requirements

For the course the only requirements will be:

1. [**Internet connection**]{.hl-yellow} (for downloading some data and packages).

2. [**Installing R**]{.hl-yellow}[: it will be our language. The download will be done (free of charge) from <https://cran.r-project.org/>]{.fragment .fade-in}


::: {.fragment .fade-in}
3.  [**Installing RStudio**]{.hl-yellow} from <https://posit.co/download/rstudio-desktop/>
:::

::: columns
::: {.column width="50%"}
![](img/cranR.jpg){width="420"}
:::

::: {.column width="50%"}
![](img/rstudio.jpg){width="420"}
:::
:::

---

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="400"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="470"}
:::
:::

::: {.fragment .fade-in-then-out}
We will program as we write (English, for example) → `R` is the [**language**]{.hl-yellow}
:::

::: {.fragment .fade-up}
- We will need a [**grammar**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}
- And an environment, for example a [**Word**]{.hl-yellow} (`RStudio`), to write it in.
:::
:::

---

## Installing R

The `R` language will be our [**grammar and spelling**]{.hl-yellow} (our rules).

::: incremental
- [**Step 1**]{.hl-yellow}: go to <https://cran.r-project.org/> and select your operating system.

- [**Step 2**]{.hl-yellow}: for Mac just click on the **.pkg file**, and open it once downloaded. For Windows systems, click on **install R for the first time** and then on **Download R for Windows**. Once downloaded, open it like any other installation file.

- [**Step 3**]{.hl-yellow}: open the installation executable.
:::

. . .

::: callout-warning
## Warning
Whenever you download something from CRAN (either R itself or a package), [**make sure you have an internet connection**]{.hl-orange}.
:::

---

## First steps

::: columns
::: {.column width="65%"}
To check that it has been installed correctly, after opening `R`, you should see a **white screen** similar to this one.

That "white screen" is called [**console**]{.hl-yellow} and we can make a first use of it as a **calculator**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="200"}
:::
:::

. . .

[**Idea**]{.hl-yellow}: let us define a variable called `a`, and it will be assigned the value `1` (type the code below in the console and hit "enter").

```{r}
#| code-line-numbers: "1"
a <- 1
```

---

## First steps

::: columns
::: {.column width="65%"}
To check that it has been installed correctly, after opening `R`, you should see a **white screen** similar to this one.

That "white screen" is called [**console**]{.hl-yellow} and we can make a first use of it as a **calculator**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Idea**]{.hl-yellow}: we will define another variable called `b` and assign it the value `2`.


```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

. . .

::: callout-note
## Note that...

In `R` we use `<-` as an arrow: the variable to the left of the arrow is assigned the value to the right (e.g. `a <- 1`).

:::

---

## First steps

::: columns
::: {.column width="65%"}
To check that it has been installed correctly, after opening `R`, you should see a **white screen** similar to this one.

That "white screen" is called [**console**]{.hl-yellow} and we can make a first use of it as a **calculator**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="270"}
:::
:::

[**Idea**]{.hl-yellow}: we will do the sum `a + b` and it will return its result.

```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```

---

## Installing R Studio

`RStudio` will be the [**Word**]{.hl-yellow} that we will use to write (what is known as an [**IDE: integrated development environment**]{.hl-yellow}).

::: incremental
- [**Step 1**]{.hl-yellow}: go to the [official RStudio website](https://posit.co/download/rstudio-desktop/) (now called Posit) and select the free download.

- [**Step 2**]{.hl-yellow}: select the executable that appears according to your operating system.

- [**Step 3**]{.hl-yellow}: after downloading the executable, open it like any other executable and let the installation finish.
:::

---

## Pane layout in RStudio

When you open `RStudio` you will probably have three windows:

- [**Console**]{.hl-yellow}: this is the name to call the big window that takes up a good part of your screen. Try writing the same code as before (the sum of the variables) in it. The console will be where we will **execute commands and show results**.

![](img/consola_rstudio.jpg){width="420"}

---

## Pane layout in RStudio

When you open `RStudio` you will probably have three windows:

-   [**Environment**]{.hl-yellow}: the small screen (you can adjust the margins) located at the upper right part. It will show us the **variables we have defined**.

![](img/environment.jpg){width="420"}

---

## Pane layout in RStudio

When you open `RStudio` you will probably have three windows:

-   [**Multi-purpose panel**]{.hl-yellow}: the window at the bottom right will not only be used to search for **function help**, but also to **view graphics**.

![](img/multiusos.jpg){width="420"}

---

## Why R?

![](img/meme_barco.jpg)

---

## Why R?

`R` is the [**main statistical language**]{.hl-yellow}, created by and for statisticians, with 5 fundamental advantages [**over Excel**]{.hl-red}:

::: incremental

- [**Programming language**]{.hl-yellow}: obviousness → [**replicable**]{.hl-purple} analysis.

- [**Free of charge**]{.hl-yellow}: the philosophy of the `R` community is code sharing under **copyleft** → [**ethical use of public money**]{.hl-purple}

- [**Open source**]{.hl-yellow}: not only is it free but it allows free access to other people's code, even to **own source code** → [**flexibility and transparency**]{.hl-purple}

- [**Modular language**]{.hl-yellow}: there are other people's code that we can reuse (almost 20 000 [**packages**]{.hl-yellow}) → [**time-saving**]{.hl-purple}

- [**High-level language**]{.hl-yellow}

:::

---

## Why R?

![](img/incel_excel.png)

---

## Why programming?

- [**Automate**]{.hl-yellow} → it will allow you to automate recurring tasks.

- [**Replicability**]{.hl-yellow} → you will be able to replicate your analysis always in the same way.

- [**Flexibility**]{.hl-yellow} → you will be able to adapt the software to your needs.

- [**Transparency**]{.hl-yellow} → it could be audited by the community.

![](img/the_general_problem.png)

---

## Main idea: packages

One of the key ideas of `R` is the [**use of packages**]{.hl-yellow}: codes that other people have implemented to **solve a problem**.

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}
- [**Installing**]{.hl-yellow}: download the codes from the web (internet required) → [**"buy a book"**]{.hl-purple}, only once (per computer)

```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}
- [**Loading**]{.hl-yellow}: after downloading the package, we indicate which packages we want to use each time we open `RStudio` → [**bring the book off the shelf**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::
:::
:::

---

## Main idea: packages

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
Once installed, there are two ways to use a package (bring it off the shelf)

::: {.fragment fragment-index="1"}
-   [**The whole package**]{.hl-yellow}: with `library()`, using the package name without quotes, we load into our session the [**whole book**]{.hl-purple}.

```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}
- [**Some particular functions**]{.hl-yellow} using `package::function` we indicate that we only want a [**concrete page of that book**]{.hl-purple}.

```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## You will be wrong

During your learning process, it is going to be very common that things don't go right the first time → [**you will make mistakes**]{.hl-yellow}. Not only will it be important to assume this, but it is [**important to read the error messages**]{.hl-yellow} to learn from them.

. . .

-   [**Error messages**]{.hl-red}: preceded by **"Error in... "** and will be those failures that [**prevent execution**]{.hl-red}.

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Warning messages**]{.hl-orange}: preceded by **"Warning in... "** are the most sensitive (possible) failures since they are inconsistencies that [**do not prevent execution**]{.hl-orange}.

```{r}
#| warning: true
# Code is ok but the result provided a NaN value, **Not A Number**, a value that is not a (real) number
sqrt(-1)
```

---

## Scripts (.R files)

::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}
A [**script**]{.hl-yellow} will be the document in which we program, our `.doc` file (here with `.R` extension) where we will write the commands. To **open our first script**, click in the menu on `File < New File < R Script`.
:::
:::

::: callout-warning
## Be careful

It is important **not to overuse the console**: everything you do not write in a script, when you close, [**you will have lost it**]{.hl-orange}.
:::

---

## Executing the first script

Now we have a **fourth window**: the window where we [**write our codes**]{.hl-yellow}. How to run it?

. . .

1. **We write** the code to execute.

. . .

2.  **Save** the .R file by clicking on `Save current document`.

. . .

3.  The code is not executed unless we tell it to do so. We have three options:

- [**Copy and paste**]{.hl-yellow} into console.
- [**Select lines**]{.hl-yellow} and `Ctrl+Enter`.
- [**Enable Source on save**]{.hl-yellow} to the right of save: it not only saves but executes the **whole code**.

---

## 💻 Your turn {#tu-turno}

[**Execute your first script**: create a script from scratch, program as indicated below and execute it (in the 3 possible ways)]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

📝 Define a variable named `a` and whose value is -1.

```{r}
#| code-fold: true
a <- -1
```

### [**Exercise 2**]{.hl-yellow}

📝 Add below another line to define a variable `b` with value 5. Then multiply both variables.

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # no saved
mult <- a * b # saved
```

### [**Exercise 3**]{.hl-yellow}

📝 Modify the code below to define two variables c and d, with values 3 and -1. Then split the variables.

```{r}
#| eval: false
c <- # you should assign the value 3
d <- # you should assign the value -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d # no saved
div <- c / d # saved
```

### [**Exercise 4**]{.hl-yellow}

📝 Assign a positive value to `x` and calculate its square root; assign another negative `y` and calculate its absolute value with the `abs()` function.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

### [**Exercise 5**]{.hl-yellow}

📝 Using the variable `x` already defined, complete/modify the code below to store in a new variable `z` the result stored in `x` minus 5.

```{r}
#| eval: false
z <- ? - ? # complete the code
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```
:::

::: callout-note
## Note that...

Functions as`sqrt()`, `abs()` or `max()` are what we call [**functions**]{.hl-purple}: lines of code that we have "encapsulated" under a name, and given some input arguments, execute the commands (a kind of shortcut).

:::

---

##  Be organized: projects

In the same way that on the computer we usually work [**ordered by folders**]{.hl-yellow}, in `RStudio` we can do the same to work in [**efficient way by creating projects**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
A [**project will be a "folder "**]{.hl-yellow} inside `RStudio`, so our working directory will automatically be the project folder itself (you can switch from one project to another with the top right menu).

We can create one in a new folder or in an existing folder.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::

---

## From the VALUE to the DATABASE

What [**data type**]{.hl-yellow} can we have in each cell of a **database**?

![](img/celdas.jpg){fig-align="middle"}

::: incremental
- [**Cell (single value)**]{.hl-yellow}: single data of a specific type.
- [**Variable**]{.hl-yellow}: **concatenation** of values of the same type ([**vectors**]{.hl-purple}).
- [**Matrix**]{.hl-yellow}: concatenation of variables of **same type and length**.
- [**Data table**]{.hl-yellow}: concatenation of variables of [**different type but equal length**]{.hl-purple}.
- [**List**]{.hl-yellow}: concatenation of variables of [**different type and different length**]{.hl-purple}
:::

---

## Type of (single) data

Are there [**variables beyond numbers**]{.hl-yellow}?


. . .

Let us think, for example, of a person's stored data:

::: {.fragment .fade-up}
- The age or weight will be a [**numeric variable**]{.hl-yellow}.

```{r}
age <- 33
```
:::

::: {.fragment .fade-up}
- Its name will be a string of [**text (string or char)**]{.hl-yellow}.

```{r}
name <- "javi"
```
:::

::: {.fragment .fade-up}
- To the question "Are you single?", the answer will be what we call as a [**logical variable**]{.hl-yellow} (`TRUE` if you are single or `FALSE` otherwise).

```{r}
single <- TRUE
```
:::

::: {.fragment .fade-up}
-   Your date of birth will be just that, a [**date**]{.hl-yellow}.

:::

---

## Numeric variables

The simplest data (we have already used it) will be the [**numeric variables**]{.hl-yellow}

```{r}
#| eval: false
a <- 5
b <- 2
a + b
```

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

. . .

To know the type of a variable we have the function `class()`.

```{r}
class(a)
```

. . .

With numeric variables we can perform the [**arithmetic operations**]{.hl-yellow} of a calculator: addition (`+`), square root (`sqrt()`), square (`^2`), etc.

```{r}
a^2
abs(a)
```

---

## String variables

Let us imagine that, in addition to the age of a person, we want to store his/her name: now the variable will be of type `character`.

```{r}
name <- "Javier"
class(name)
```

. . .

[**Strings variables**]{.hl-yellow} are a type with which we obviously [**cannot perform arithmetic operations**]{.hl-red} (other operations such as pasting or locating patterns can be performed).

```{r}
#| error: true
name + 1
```

. . .

::: callout-warning
## Note that...

String variables are [**ALWAYS in quotes**]{.hl-orange}: `TRUE` (logical, binary value) is not the same as `"TRUE"` (char or string).
:::

---

## First function: paste

In `R` we denote as [**function**]{.hl-yellow} a piece of [**encapsulated code**]{.hl-yellow} under a name, and which depends on some input [**arguments**]{.hl-yellow}. Our first function will be `paste()`: given two strings, it allows us to paste them together.

```{r}
paste("Javier", "Álvarez")
```

. . .

Note that [**default**]{.hl-yellow} pastes strings with a space, but we can add an [**optional argument**]{.hl-yellow} to tell it the separator (in `sep = ...`).

```{r}
paste("Javier", "Álvarez", sep = "*")
```

---

## First function: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}
How to know [**what arguments a function needs**]{.hl-yellow}? By typing `? paste` in the console, you will get a [**help**]{.hl-yellow} in the multi-purpose panel.

In this help panel, you will see in its header what arguments the function already has [**default**]{.hl-yellow} assigned to it.
:::
:::

. . .

There is a similar function named as `paste0()` that pastes by default with `sep = ""` (without anything else).

```{r}
paste0("Javier", "Álvarez")
```

---

## First package: glue

A more intuitive way to work with string variables is to use the `{glue}` package: the first thing to do is to "buy the book" (if we have never done it before). After that [**load the package**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue")
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

This package allows us to use [**variables inside strings**]{.hl-yellow}. For example, "I am ... years old", where the age is stored in a variable.

```{r}
age <- 33
glue("I am {age} years old")
```

. . .

Inside brackets we can also execute operations

```{r}
units <- "days"
glue("I am {age * 365} {units} old")
```

---

## Logical conditions

Another fundamental type will be the [**logical or binary or boolean variables**]{.hl-yellow} (**just two values**):

- `TRUE`: [**true**]{.hl-yellow} stored internally as a 1.
- `FALSE`: [**false**]{.hl-yellow} stored internally as a 0.

```{r}
single <- TRUE # Are you single? --> YES
class(single)
```

. . .

It can take a third value, `NA` or [**missing data**]{.hl-yellow}, the acronym for *not available*.

. . .

::: callout-important
## Important

Logical variables [**NOT string variables**]{.hl-red}: `"TRUE"` is a string, `TRUE` is a logical value.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Logical conditions

Logical values are usually the result of [**evaluate logical conditions**]{.hl-yellow}. For example, let us imagine we want to check if my name is Javi.

```{r}
name <- "María"
```

. . .

The [**logical operator**]{.hl-yellow} `==` allow us to ask if left equals right.

```{r}
name == "Javi"
```

. . .

With its opposite `!=` we ask if it is different.

```{r}
name != "Javi"
```

. . .

::: callout-note
## Note that...

It is not the same `<-` ([**assignment**]{.hl-yellow}) as `==` (we are [**asking**]{.hl-yellow}, it is a logical comparison).

:::

---

## Logical conditions

In addition to "equal to" versus "different" comparisons, also order comparisons such as `<, <=, > or >=`.

**Is the person less than 32 years old?**

```{r}
age <- 38
age < 32
```

**Age is greater than or equal to 38 years old?**

```{r}
age >= 38
```


---

## Date variables

A very special data type: the [**date type data**]{.hl-yellow}.

```{r}
date_char <- "2021-04-21"
```

. . .

It looks like a simple string but [**represents an instant in time**]{.hl-yellow}. What should happen if [**we add a 1 to a date**]{.hl-purple}?

```{r}
#| error: true
date_char + 1
```

. . .

Dates [**cannot be string variables**]{.hl-red}: we must convert string variables to date with `as_date()` from the `{lubridate}` package.


```{r}
library(lubridate)
date <- as_date("2023-03-28")
date + 1
class(date)
```

---

## Date variables

In this package we have very useful functions for [**handling dates**]{.hl-yellow}:

-   `today()` allowes to directly obtain the [**current date**]{.hl-purple}.

```{r}
today()
```

. . .

-  `now()` allows to obtain [**current datetime**]{.hl-purple}

```{r}
now()
```

. . .

-  `year()`, `month()` or `day()` allows us to [**extract year, month and day**]{.hl-purple} for a given date.

```{r}
date <- today()
year(date)
month(date)
```

---

## Cheatsheets

![](img/lubridate.png)

::: callout-note
## More documentation

You have a pdf summary of the most important packages in the [**corresponding folder on campus**]{.hl-green}. See also <https://posit.co/resources/cheatsheets/>
:::

---

## 💻 Your turn {#tu-turno-1}

[**Try to solve the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

📝 Define a variable that stores your age (named as `age`) and another with your name (named as `name`).

```{r}
#| code-fold: true
age <- 33
name <- "Javi"
```

### [**Exercise 2**]{.hl-yellow}

📝 Define another variable named as `siblings` that answers the question "do you have siblings?" and another one with the date of your birth (named as `birth_date`).

```{r}
#| code-fold: true
siblings <- TRUE

library(lubridate)
birth_date <- as_date("1989-09-10")
```

### [**Exercise 3**]{.hl-yellow}

📝 Define another variable with your last names (named as `surnames`) and use `glue()` to have a single variable `full_name` (separating first and last name by a comma).

```{r}
#| code-fold: true
#| eval: false
surnames <- "Álvarez Liébana"
glue("{name}, {surnames}")
```

### [**Exercise 4**]{.hl-yellow}

📝 Compute the days that have passed from the date of your birth until today (with the date of birth defined in exercise 2).

```{r}
#| code-fold: true
#| eval: false
today() - birth_date
```
:::

---

## Vectors: concatenate

Working with data usually implies having [**columns that represent variables**]{.hl-yellow}: we will call [**vectors**]{.hl-yellow} a [**concatenation**]{.hl-purple} of cells (values) of the [**same type**]{.hl-purple}.

. . .

The simplest way is using the `c()` command (c, **concatenate**), and just introduce its **elements between parentheses, and separated by commas**.

```{r}
age <- c(33, 27, 60, 61)
age
```

. . .

::: callout-tip
A single number `x <- 1` (or `x <- c(1)`) is actually a vector of length one.
:::

---

## Vectors: concatenate

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}
As you can see, in the `environment` area we have now a **collection of elements** saved

```{r}
age
```
:::
:::

. . .

The [**length of a vector**]{.hl-yellow} can be computed with `length()`.

```{r}
length(age)
```

. . .

We can also  [**concatenate vectors themselves**]{.hl-yellow}

```{r}
c(age, age, 8)
```

---

## Numerical sequences

Many times we will want to create [**numeric sequences**]{.hl-yellow} (for example, the days of the month). The `seq(start, end)` command allows us to create a **sequence** from a start element to an end element, [**advance one at a time**]{.hl-purple}.

```{r}
seq(1, 31)
```

. . .

The command `1:n` returns the same as `seq(1, n)` (if the initial element is greater than the final one, it will understand that the sequence is [**decreasing**]{.hl-purple}).

```{r}
1:5
7:-3
```

---

## Numerical sequences

We can also define [**other type of discretization step**]{.hl-yellow} between consecutives

```{r}
seq(1, 7, by = 0.5) # from 1 to 7 by step = 0.5
```

. . .

In other cases we will be interested in defining a [**sequence with a specific length**]{.hl-yellow}

```{r}
seq(1, 50, l = 7) # length 7
```

. . .

We may even want to generate a vector of [**n repeated elements**]{.hl-yellow}.

```{r}
rep(0, 7)
```

---

## Vectors: characters

A vector is a **concatenation** of [**same type**]{.hl-yellow} elements, but they do not necessarily have to be numerical types. Let us create an example sentence.

```{r}
sentence <- "I am Javi"
sentence
length(sentence)
```

. . .

In the previous case it was not a vector, it was a single text element. To create a vector we must use `c()` again and separate elements with commas.

```{r}
vector <- c("I", "am", "Javi")
vector
length(vector)
```

---

## Vectors

What will happen if we [**concatenate elements of different type**]{.hl-yellow}?

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

Notice that since they are all of the same type, what `R` does is [**convert**]{.hl-yellow} everything to character,  [**violating data integrity**]{.hl-red}

. . .

```{r}
c(3, 4, TRUE, FALSE)
```

It is important to understand that the logical values are actually [**stored internally as 0/1**]{.hl-yellow}

---

## Operating with vectors

With numeric vectors we can do the same [**arithmetic operations**]{.hl-yellow} as with numbers → a [**number is a vector**]{.hl-purple} (of length one).

. . .

What will happen if we [**add or subtract a value**]{.hl-yellow} to a vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Be careful

Unless we indicate otherwise, in `R` operations with vectors are always [**element to element**]{.hl-orange}
:::

---

## Operating with vectors

Vectors can also interact with each other, so we can define, for example, [**sums of vectors**]{.hl-yellow} (element by element)

```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

. . .

Since the operation (e.g., a sum) is performed element by element, what will happen if [**let's add two vectors of different length**]{.hl-yellow}?

. . .

```{r}
z <- c(1, 3, 5, 7)
x + z
```

What it does is [**recycle elements**]{.hl-yellow}: if you have a vector of 4 elements and we add another one of 3 elements, it will recycle from the vector with smaller length.

---

## Operating with vectors

A very common operation is to [**ask data**]{.hl-yellow} by using [**logical conditions**]{.hl-purple}. For example, if we define a vector of temperatures....

[**What days was it less than 22 degrees**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

It will return a [**logical vector**]{.hl-yellow}, depending on whether **each element** fulfills or not the requested condition (of **equal length** to the requested vector).

. . .

If we had a [**missing data**]{.hl-yellow} (e.g., due to device error that day), the evaluated condition would also be `NA`.

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Operating with vectors

Logical [**conditions can be combined**]{.hl-yellow} in two ways:

- [**Intersection**]{.hl-yellow}: [**all**]{.hl-purple} concatenated conditions must be checked ([**conjunction and**]{.hl-purple} with `&`) to return a `TRUE`.

```{r}
x < 30 & x > 15
```

-    [**Union**]{.hl-yellow}: it is sufficient that [**at least one**]{.hl-purple} is fulfilled ([**conjunction or**]{.hl-purple} with `|`).

```{r}
x < 30 | x > 15
```

. . .

`any()` and `all()` allow us to check that [**all (or any) elements**]{.hl-yellow} meet the following criteria

```{r}
any(x < 30)
all(x < 30)
```

---

## Operating with vectors

We can also use [**statistical operations**]{.hl-yellow} such as `sum()` which, given a vector, returns the sum of all its elements.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**What happens when a single value is missing?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

By default, if we have a missing data, the [**operation will also be missing**]{.hl-yellow}. In order to [**remove that data**]{.hl-purple}, we use an optional argument `na.rm = TRUE`.

```{r}
sum(x, na.rm = TRUE)
```

---

## Operating with vectors

As we have mentioned, logical values are stored internally as 0 and 1, so we can use them in arithmetic operations.


For example, if we want to [**find the number of elements that fulfill a condition**]{.hl-yellow} (for example, "less than 3"), those that do will be assigned a 1 (`TRUE`) and those that don't a 0 (`FALSE`), so we only need to add this logical vector to obtain the number of elements that fulfill a condition.

```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Operating with vectors

Other common operations are [**average**]{.hl-yellow}, [**median**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.


- [**Average (mean)**]{.hl-yellow}: centrality measure that consists of adding all the elements and dividing by the number of elements added. The best known but the [**least robust**]{.hl-red}: given a set, if outliers (very large or very small values) are introduced, the mean is strongly perturbed.


```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Operating with vectors

Other common operations are [**average**]{.hl-yellow}, [**median**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.


-   [**Median**]{.hl-yellow}: measure of centrality that consists of ordering the elements and keeping the one that occupies the middle.


```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Percentiles**]{.hl-yellow}: measures of location (they divide the data into equal parts).

```{r}
quantile(x) # por defecto percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

---

## Operating with vectors

Another very common operation is to [**access elements**]{.hl-yellow} of it. The simplest way is to use the `[i]` operator (access the i-th element).

```{r}
age <- c(20, 30, 33, NA, 61) 
age[3] # third position
```

. . .


Since a number is just a vector of length one, this operation can also be applied using a [**vector of indexes to select**]{.hl-yellow}

```{r}
y <- c("Hi", "how", "are", "you", "?")
y[c(1:2, 4)] # first, second and fourth elemento
```

::: callout-tip
To access the last one, without worrying about which one, we can pass as index the length `x[length(x)]`.

:::

---

## Operating with vectors

Other times we will not want to select but [**delete some elements**]{.hl-yellow}. We will have to repeat the same operation but with the sign `-` in front: the operator `[-i]` does not select the i-th element of the vector but discards it.

```{r}
y
y[-2]
```


. . .

Many times we will want to [**select or eliminate based on logical conditions**]{.hl-yellow}, depending on the values, so we will pass as index the condition itself (remember, `x < 2` returns a logical vector).

```{r}
age <- c(15, 21, 30, 17, 45)
names <- c("javi", "maría", "laura", "carla", "luis")
names[age < 18] 
```

---

## Operating with vectors

Finally, a common action is to [**sort values**]{.hl-yellow}:

-   `sort()`: returns the [**sorted vector**]{.hl-yellow}. By default from smallest to largest but with `decreasing = TRUE` we can change it.

```{r}
age <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(age)
sort(age, decreasing = TRUE)
```

. . .

-   `order()`: returns the [**index vector**]{.hl-yellow} that we would have to use to have the sorted vector.

```{r}
order(x)
x[order(x)]
```

---

## 💻 Your turn {#tu-turno-2}

[**Try to solve the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

📝 Define the vector `x` as the concatenation of the first 5 odd numbers, and calculate their sum.

```{r}
#| code-fold: true
#| eval: false
# Two ways
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

sum(x)
```

### [**Exercise 2**]{.hl-yellow}

📝 Get the elements of `x` greater than 4. Calculate the number of elements of `x` greater than 4.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
sum(x > 4)
```

### [**Exercise 3**]{.hl-yellow}

📝 Calculate the vector `1/x` and obtain the ordered version (from smallest to largest).

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Exercise 4**]{.hl-yellow}

📝 Find the maximum and minimum of vector `x`.

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Exercise 5**]{.hl-yellow}

📝 Find of the vector `x` the elements greater (strictly) than 1 and less (strictly) than 7. Find a way to find out if all the elements are positive or not.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Exercise 6**]{.hl-yellow}

📝 Given the vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extract the elements that occupy the places 1, 2, 5, 6. Removes from the vector the second element. After removing it, compute its sum and mean

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
y <- x[-2]
sum(y, na.rm = TRUE)
mean(y, na.rm = TRUE)
```
:::

---

## 🐣 Case study {#caso-práctico-1}

In the `{datasets}` package we have several datasets, and one of them is named as `airquality`. I have extracted below 3 variables from this dataset

```{r}
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

1. What [**represents the data**]{.hl-yellow}? How to find out?

. . .

2. How many [**records do we have for May**]{.hl-yellow}? What about April? Construct a new `date` variable with the [**date**]{.hl-yellow} of each record (combining year, month and day).

. . .

3. Create a new variable `temp_celsius` with the [**temperature in ºC**]{.hl-yellow} (units of the original variable are in Fahrenheit)

. . .

4. What was the [**average temperature**]{.hl-yellow} for the month of August? Extract the days when the [**temperature exceeded 30 degrees**]{.hl-yellow} and determine the number of days when it did.


# Lesson 2: first databases {#clase-2}

[**First databases: tibbles as standard type for databases. R base vs tidyverse. Pipe operator. Principles of tidy data: tidy vs messy data. Pivoting datasets**]{style="color:#444442;"}

---


## First attempt: matrices

In data science we usually have [**several variables**]{.hl-yellow} for each individual: we need a "table" to collect them. The most immediate option is [**matrices**]{.hl-yellow}: a concatenation of variables of [**same type and equal length**]{.hl-purple}.

. . .

Let us imagine that we have heights and weights of 4 people. How to [**create a dataset with those variables**]{.hl-yellow}?


-   Function `cbind()` allow us to [**concatenate vectors by columns**]{.hl-yellow}

```{r}
heights <- c(150, 160, 170, 180)
weights <- c(63, 70, 85, 95)
data_matrix <- cbind(heights, weights)
data_matrix
```

---

## First attempt: matrices

- We can also [**define a matrix by rows**]{.hl-yellow} with the `rbind()` function (although it is recommended to have each variable in column and individuals in row).

```{r}
rbind(heights, weights)
```

- We can [**view the matrix**]{.hl-yellow} (in a tabular way) using the function `View()`.

. . .

- We can [**check dimensions**]{.hl-yellow} with `dim()`, `nrow()` and `ncol()` (data is now tabulated).

```{r}
dim(data_matrix)
nrow(data_matrix)
```

---

## First attempt: matrices

- We can also [**transpose a matrix**]{.hl-yellow} with `t()`.

```{r}
t(data_matrix)
```

. . .

- Since we now have two dimensions, to [**access elements**]{.hl-yellow} we must provide the index of the row and column inside of brackets (if they are free, it implies all of that dimension)

```{r}
data_matrix[2, 1]
data_matrix[, 2]
```

---

## First attempt: matrices

- We can also define a [**matrix from a numeric vector**]{.hl-yellow}, reorganizing the values in the form of a matrix (knowing that the elements are **placed by columns**).

```{r}
z <- matrix(1:15, ncol = 5) 
z
```

. . .

With matrices it is the same as with vectors: when we apply an [**arithmetic operation, we do it element by element**]{.hl-yellow}

```{r}
z/5
```

---

## First attempt: matrices

We can also apply [**apply functions by columns/rows**]{.hl-yellow} (avoiding loops) with `apply()`, taking as **input arguments**

- a matrix
- the sense in which operation must be applied (`MARGIN = 1` by rows, `MARGIN = 2` by columns)
- a function to be applied.

. . .

```{r}
# Mean by columns (MARGIN = 2)
apply(data_matrix, MARGIN = 2, FUN = "mean")

# (Quasi)var (var) by columns (MARGIN = 2)
apply(data_matrix, MARGIN = 2, FUN = "var")
```

. . .

[**We won't go deeper**]{.hl-red} any further since our goal is to have variables of the same length but [**different types**]{.hl-yellow} (but know they exist).

---

## 💻 Your turn (matrices) {#tu-turno-matrices}

[**Try to solve the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

📝 Modify the code below to define an `x` matrix of ones with 3 rows and 7 columns.

```{r}
#| eval: false
x <- matrix(0, nrow = 2, ncol = 3)
x
```

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1, nrow = 3, ncol = 7)
x
```

### [**Exercise 2**]{.hl-yellow}

📝 Add a 1 to each number in the matrix above, and divide the result by 5. After that, calculate its transpose and obtain its dimensions

```{r}
#| code-fold: true
#| eval: false
new_matrix <- (x + 1)/5
t(new_matrix)
dim(new_matrix)
```

### [**Exercise 3**]{.hl-yellow}

📝 Define matrix `x <- matrix(1:12, nrow = 4)`. Get the first row, the third column, and the element (4, 1).

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
x[1, ] # first row
x[, 3] # third column
x[4, 1] # element (4, 1)
```

### [**Exercise 4**]{.hl-yellow}

📝 With the above matrix defined as `x <- matrix(1:12, nrow = 4)`, calculate the mean of all elements, the mean of each row and the mean of each column. Calculate the sum of each row and each column.

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
mean(x) # mean (of all elements)
apply(x, MARGIN = 1, FUN = "mean") # mean by rows
apply(x, MARGIN = 2, FUN = "mean") # mean by columns
apply(x, MARGIN = 1, FUN = "sum") # sum by rows
apply(x, MARGIN = 2, FUN = "sum") # sum by columns

```
:::

---

## Second attempt: data.frame

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte

```{r}
#| code-line-numbers: "4-5"
edades <- c(14, 24, NA)
soltero <- c(TRUE, NA, FALSE)
nombres <- c("javi", "laura", "lucía")
matriz <- cbind(edades, soltero, nombres)
matriz
```

. . .

Al ya no ser números no podemos realizar operaciones aritméticas

```{r}
#| error: true
matriz + 1
```

---

## Second attempt: data.frame

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos lo que se conoce como [**data.frame**]{.hl-yellow}: concatenación de variables de igual longitud pero pueden ser de [**tipo distinto**]{.hl-purple}.

```{r}
#| code-line-numbers: "1"
tabla <- data.frame(edades, soltero, nombres)
class(tabla)
tabla
```

---

## Second attempt: data.frame

Dado que un `data.frame` es ya una «base de datos» las variables no son meros vectores matemáticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple}

```{r}
library(lubridate)
tabla <- data.frame("edad" = edades, "estado" = soltero, "nombre" = nombres,
             "f_nacimiento" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
tabla
```

---

## Second attempt: data.frame

[**¡TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

![](img/view_tabla.jpg)

---

## Second attempt: data.frame

Si queremos acceder a sus elementos, podemos como en las matrices (aunque no es recomendable): ahora [**tenemos dos índices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera característica de la segunda persona
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
También tiene ventajas de una [**«base» de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} (**recomendable** ya que las variables pueden cambiar de posición), poniendo el nombre de la tabla seguido del símbolo `$` (con el **tabulador**, nos aparecerá un menú de columnas a elegir)
:::
:::

---

## Second attempt: data.frame

-   `names()`: nos muestra los nombres de las variables

```{r}
names(tabla)
```

. . .

-   `dim()`: nos muestra las dimensiones (también `nrow()` y `ncol()`)

```{r}
dim(tabla)
```

. . .

-   Podemos acceder a las variables por su nombre

```{r}
tabla[c(1, 3), "nombre"]
```

---

## Second attempt: data.frame

Si tenemos uno ya creado y queremos [**añadir una columna**]{.hl-yellow} es tan simple como usar la función `data.frame()` que ya hemos visto para concatenar la columna. Vamos añadir por ejemplo una nueva variable, el número de hermanos de cada individuo.

```{r}
# Añadimos una nueva columna con nº de hermanos/as
hermanos <- c(0, 2, 3)
tabla <- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```

---

## Final attempt: tibble

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}

La principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC

```{r}
#| error: true
data.frame("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
           "IMC" = peso / (estatura^2))
```

. . .

 

De ahora en adelante usaremos el formato `tibble` (un [**data.frame mejorado**]{.hl-yellow})

```{r}
library(tibble)
tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
       "IMC" = peso / (estatura^2))
```

---

## Final attempt: tibble

```{r}
tabla <- tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
                "IMC" = peso / (estatura^2))
tabla
```

Las tablas en formato `tibble` nos permitirá una [**gestión más ágil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

. . .

-   [**Metainformación**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya automáticamente el número de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

---

## Final attempt: tibble

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

```{r}
#| warning: true
tabla$invent
```

. . .

-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
El paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de páginas web y documentos sencillos
:::


---

## 💻 Tu turno (tibble) {#tu-turno-tibble}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 Carga del paquete `{datasets}` el conjunto de datos `airquality` (variables de la calidad del aire de Nueva York desde mayo hasta septiembre de 1973). ¿Es el conjunto de datos airquality de tipo tibble? En caso negativo, conviértelo a tibble (busca en la documentación del paquete en <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Una vez convertido a `tibble` obtén el nombre de las variables y las dimensiones del conjunto de datos. ¿Cuántas variables hay? ¿Cuántos días se han medido?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Filtra solo los datos del mes de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, ]
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Selecciona aquellos datos que no sean ni de julio ni de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[!(airquality_tb$Month %in% c(7, 8)), ]
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Modifica el siguiente código para quedarte solo con las variable de ozono y temperatura.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[, c("Ozone", "Temp")]
```

### [**Ejercicio 6**]{.hl-yellow}

📝 Selecciona los datos de temperatura y viento de agosto. Traduce a castellano el nombre de las columnas del conjunto filtrado.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, c("Temp", "Wind")]
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```
:::

---

## Summary

-   Cada [**celda puede ser de un tipo diverso**]{.hl-yellow}: números, texto, fechas, valores lógicos, etc

. . .

-   Un [**vector es una concatenación de celdas**]{.hl-yellow} (las futuras columnas de nuestras tablas) --\> En `R` por defecto las operaciones se hacen [**elemento a elemento**]{.hl-yellow}

. . .

-   Una [**matriz**]{.hl-yellow} nos permite concatenar [**variables del MISMO tipo y MISMA longitud**]{.hl-yellow} --\> objeto bidimensional (dos índices)

. . .

-   Un [**data.frame**]{.hl-yellow} nos permite concatenar [**variables de DISTINTO tipo y MISMA longitud**]{.hl-yellow} --\> usaremos [**tibble**]{.hl-yellow} como una opción mejorada de base de datos

---

## 🐣 Caso práctico {#caso-práctico-1}

Del paquete `Biostatistics` usaremos el conunto de datos `pinniped`

```{r}
#| eval: false
Biostatistics::pinniped
```


1. ¿Qué [**representan**]{.hl-yellow} los datos? ¿Qué [**tipo de dato**]{.hl-yellow} es? En caso de que no lo sea, convierte la base de datos a un `tibble` (renombra con `pinniped_tb`)

. . .

2. ¿Cuántos registros hay? ¿Y variables? ¿De qué tipo es cada una?

. . .

3. Incorpora una [**variable extra llamada phoca**]{.hl-yellow} que sea de tipo lógico y que nos diga si una especie es de la categoría `Phoca` o no.

. . .

4. ¿A qué sexo le [**pesa más el cerebro**]{.hl-yellow}: a las hembras o a los machos? ¿A quienes les [**pesa más el cuerpo**]{.hl-yellow}: a los monógamos o a los polígamos?

. . .

5. Incopora una nueva variable que represente la [**diferencia entre el peso del cerebro entre machos y hembras**]{.hl-yellow} (machos - hembras) para cada especie.


---

## R base vs Tidyverse

Si conoces algún otro lenguaje de programación (o tienes gente cercana que programa) te extrañará que aún no hayamos hablado de conceptos habituales como

-   [**Bucles for**]{.hl-yellow}: repetir un código un número fijo de iteraciones.

-   [**Bucles while**]{.hl-yellow}: repetir un código hasta que se cumpla una condición

-   [**Estructuras if-else**]{.hl-yellow}: estructuras de control para decidir por donde camina el código en función del valor de las variables.

. . .

Y aunque conocer dichas estructuras puede sernos en algún momento interesante, en la [**mayoría de ocasiones vamos a poder evitarlas**]{.hl-red} (en especial los bucles)

---

## What about tidyverse?

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

`{tidyverse}` es un [**«universo» de paquetes**]{.hl-yellow} para garanatizar un flujo de trabajo (de inicio a fin) eficiente, coherente y lexicográficamente sencillo de entender, basado en la idea de que [**nuestros datos están limpios y ordenados (tidy)**]{.hl-purple}

---

## What about tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: optimizando data.frame
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: gramática para depurar
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualización de datos
-   `{tidymodels}`: modelización/predicción
:::
:::

También tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.

---

## What about tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: [**limpieza de datos**]{.hl-yellow}
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: gramática para depurar
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualización de datos
-   `{tidymodels}`: modelización/predicción
:::
:::

También tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.

---

## Idea: Tidy Data

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

::: {style="font-size:120px; text-align: center; color:#F8DF58;"}
<b>TIDY</b><b>[VERSE</b>]{style="color:#CAB0EE;"}
:::

El [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducido por **Hadley Wickham** (el Dios al que rezo) de [**estandarizar**]{.hl-yellow} el formato los datos para

::: incremental
-   [**sistematizar**]{.hl-green} la depuración
-   hacer más [**sencillo**]{.hl-green} su manipulación.
-   código [**legible**]{.hl-green}
:::

---

## Tidy data: rules

Lo primero por tanto será entender qué son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos están estandarizados.

::: columns
::: {.column width="50%"}
::: {.fragment .fade-in}
1.  Cada [**variable**]{.hl-yellow} en una [**única columna**]{.hl-purple}
:::

::: {.fragment .fade-in}
2.  Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}
:::

::: {.fragment .fade-in}
3.  Cada [**celda**]{.hl-yellow} con un [**único valor**]{.hl-purple}
:::

::: {.fragment .fade-in}
4.  Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}
:::

::: {.fragment .fade-in}
5.  Si queremos cruzar [**múltiples tablas**]{.hl-yellow} debemos tener una [**columna común**]{.hl-purple}
:::
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
:::

---

## Pipe operator

En `{tidyverse}` será clave el [**operador pipe (tubería)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): será una [**tubería que recorre los datos**]{.hl-yellow} y los transforma.

. . .

::: columns
::: {.column width="50%"}
En R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, sería

```{r}
#| eval: false
third(second(first(datos)))
```
:::

::: {.column width="50%"}
En `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones

```{r}
#| eval: false
datos |> first() |> second() |> third()
```
:::
:::

 

. . .

::: callout-caution
## Apunte importante

Desde la versión 4.1.0 de `R` disponemos de `|>`, un pipe **nativo** disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que dependía del paquete `{magrittr}` (bastante problemático).
:::

---

## Pipe operator

La principal ventaja es que el [**código sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas código.

 

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::

::: {.column width="50%"}
<center><img src="img/logo_pipe.png" width="360px"/></center>
:::
:::

---

## Messy data

¿Pero qué aspecto tienen los [**datos no tidy**]{.hl-yellow}? Vamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).

 

```{r}
library(tidyr)
table4a
```

 

[**¿Qué puede estar fallando?**]{.hl-red}

---

## Pivoting: pivot_longer()

::: columns
::: {.column width="40%"}
```{r}
table4a
```
:::

::: {.column width="60%"}
❎ Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) → las columnas `1999` y `2000` en realidad deberían ser en sí [**valores de una variable**]{.hl-yellow} y no nombres de columnas.
:::
:::

. . .

Incluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el año y otra que guarde el valor de la variable de interés en cada uno de esos años. Y lo haremos con la función `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

---

## Pivoting: pivot_longer()

::: columns
::: {.column width="50%"}
```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year",
               values_to = "cases")
```
:::

::: {.column width="50%"}
![](img/table4a.jpg)
:::
:::

 

-   `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}
-   `names_to`: nombre de la nueva variable a la quemandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).
-   `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.

---

## Messy data

Veamos otro ejemplo con la tabla `table2`

 

```{r}
table2
```

 

[**¿Qué puede estar fallando?**]{.hl-red}

---

## Pivoting: pivot_wider()

::: columns
::: {.column width="60%"}
```{r}
#| echo: false
table2
```
:::

::: {.column width="40%"}
❎ Cada [**observación está dividido en dos filas**]{.hl-red} → los [**registros con el mismo año deberían ser el mismo**]{.hl-yellow}
:::
:::

. . .

Lo que haremos será lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}

```{r}
table2 |>  pivot_wider(names_from = type, values_from = count)
```

---

## Messy data

Veamos otro ejemplo con la tabla `table3`


```{r}
table3
```


[**¿Qué puede estar fallando?**]{.hl-red}

---

## separate()

::: columns
::: {.column width="60%"}
```{r}
table3
```
:::

::: {.column width="40%"}
❎ Cada [**celda contiene varios valores**]{.hl-red}
:::
:::

. . .

Lo que haremos será hacer uso de la función `separate()` para mandar [**separar cada valor**]{.hl-yellow} a una columna diferente.

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

---

## separate()

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

Fíjate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deberían ser variables numéricas. Para ello podemos añadir el argumento opcional `convert = TRUE`

. . .

```{r}
table3 |> separate(rate, into = c("cases", "pop"), convert = TRUE)
```

---

## Messy data

Veamos el último ejemplo con la tabla `table5`


```{r}
table5
```


[**¿Qué puede estar fallando?**]{.hl-red}

---

## unite()

::: columns
::: {.column width="50%"}
```{r}
table5
```
:::

::: {.column width="50%"}
❎ Tenemos [**mismos valores divididos en dos columnas**]{.hl-red}
:::
:::

. . .

Usaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y año en una misma columna

```{r}
table5 |> unite(col = year_completo, century, year, sep = "")
```

---

## 💻 Tu turno {#tu-turno-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
table4b |>
  pivot_longer(cols = "1999":"2000", names_to = "year",
               values_to = "cases")
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Echa un vistazo a la tabla `relig_income` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused",
               names_to = "income",
               values_to = "people")
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
billboard |>
  pivot_longer(cols = "wk1":"wk76",
               names_to = "week",
               names_prefix = "wk",
               values_to = "position",
               values_drop_na = TRUE)
```

:::

---

## 🐣 Caso práctico {#caso-práctico-2}

En el paquete `{tidyr}` contamos con el dataset `who` (dataset de la Organización Mundial de la Salud)

```{r}
#| eval: false
library(tidyr)
who
```


1. ¿Qué [**significan los datos**]{.hl-yellow}? ¿Cuántas [**variables y observaciones**]{.hl-yellow} tenemos?

. . .

2. ¿Cuántos [**tipos de variables**]{.hl-yellow} tenemos?

. . .

3. ¿Todas las variables son necesarias? [**Elimina la información redundante**]{.hl-yellow}.

. . .

4. [**Convierte a tidydata**]{.hl-yellow} la base de datos realizando todas las opciones que consideres (consejo: usa papel y boli para bocetar como debería quedar la base de datos).



# Lesson 3: control flow structures and rmd {#clase-3}

[**Loops vs vectorial programming. Control flow estructures. Rmarkdown and Quarto**]{style="color:#444442;"}


---

## ...
